<?xml version="1.0" encoding="UTF-8"?><Db flnm="dev_turisticgis" nm="dev_turisticgis" ver="1.3.4">
  <VerLbl/>
  <VerNotes/>
  <DefTblOpts/>
  <DocFolder>/home/www/turisticgis/sviluppo</DocFolder>
  <Sch Cm="standard public schema" nm="public">
    <Tbl UsSo="1" nm="capabilities">
      <Cm>Tabella che tiene conto delle capacit√† dei vaeri ruoli</Cm>
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pkcapabilities"/>
      <Cl au="1" df="nextval('capabilities_id_seq'::regclass)" nm="id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="name" nu="0">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="description" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="capabilities_roles">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pkcapabilities_roles"/>
      <Cl au="1" df="nextval('capabilities_roles_id_seq'::regclass)" nm="id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="capability_id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="role_id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_capabilities_roles_capabilities" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="capabilities" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="capabilities_roles" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="capability_id" prCl="id"/>
      </Fk>
      <Fk deAc="3" nm="fk_capabilities_roles_roles" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="roles" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="capabilities_roles" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="role_id" prCl="id"/>
      </Fk>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="geometry_columns">
      <TblOpts>WITH OIDS</TblOpts>
      <Pk ClNs="f_table_catalog, f_table_schema, f_table_name, f_geometry_column" nm="geometry_columns_pk"/>
      <Cl au="0" df="" nm="f_table_catalog" nu="0">
        <DT ds="VarChar" en="" id="12" ln="256" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="f_table_schema" nu="0">
        <DT ds="VarChar" en="" id="12" ln="256" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="f_table_name" nu="0">
        <DT ds="VarChar" en="" id="12" ln="256" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="f_geometry_column" nu="0">
        <DT ds="VarChar" en="" id="12" ln="256" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="coord_dimension" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="srid" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="type" nu="0">
        <DT ds="VarChar" en="" id="12" ln="30" sc="null" sg="1" un="0"/>
      </Cl>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="i18n">
      <Cm>Tabella delle traduzioni rispeto a quella base</Cm>
      <TblOpts/>
      <Pk ClNs="id" nm="pki18n"/>
      <Cl au="1" df="" nm="id" nu="0">
        <DT ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="1"/>
      </Cl>
      <Cl au="0" df="" nm="tb" nu="0">
        <DT ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="col" nu="0">
        <DT ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="val" nu="0">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="itineraries">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pkitineraries"/>
      <Cl au="1" df="nextval('itineraries_id_seq'::regclass)" nm="id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="name" nu="0">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="description" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="itineraries_paths">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pkitineraries_paths"/>
      <Cl au="1" df="nextval('itineraries_paths_id_seq'::regclass)" nm="id" nu="0">
        <DT ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="itinerary_id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="path_id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="3" nm="fk_itineraries_paths_itineraries" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="itineraries" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="itineraries_paths" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="itinerary_id" prCl="id"/>
      </Fk>
      <Fk deAc="3" nm="fk_itineraries_paths_paths" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="paths" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="itineraries_paths" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="path_id" prCl="id"/>
      </Fk>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="itineraries_pois">
      <Cm>Tabella di collegamento na m per itinerari e poi</Cm>
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pkitineraries_pois"/>
      <Cl au="1" df="nextval('itineraries_pois_id_seq'::regclass)" nm="id" nu="0">
        <DT ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="itinerary_id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="poi_id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="3" nm="fk_itineraries_pois_itineraries" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="itineraries" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="itineraries_pois" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="itinerary_id" prCl="id"/>
      </Fk>
      <Fk deAc="3" nm="fk_itineraries_pois_pois" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="pois" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="itineraries_pois" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="poi_id" prCl="id"/>
      </Fk>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="paths">
      <Cm>Tabella dei percorsi</Cm>
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pkpaths"/>
      <Cl au="1" df="nextval('paths_gid_seq'::regclass)" nm="id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="title" nu="0">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="description" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="length" nu="1">
        <DT ds="Double" en="" id="8" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="altitude_gap" nu="1">
        <DT ds="Double" en="" id="8" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="general_features" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="reason" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="accessibility" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="information_url" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="the_geom" nu="1">
        <DT ds="geometry" en="" id="5001" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="pois">
      <Cm>Point of interest</Cm>
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pkpois"/>
      <Cl au="1" df="nextval('pois_gid_seq'::regclass)" nm="id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="title" nu="0">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="description" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="reason" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="accessibility" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="information_url" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="the_geom" nu="1">
        <DT ds="geometry" en="" id="5001" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="roles">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pkroles"/>
      <Cl au="1" df="nextval('roles_id_seq'::regclass)" nm="id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="name" nu="0">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="description" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="level" nu="1">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="roles_users">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pkroles_users"/>
      <Cl au="1" df="nextval('roles_users_id_seq'::regclass)" nm="id" nu="0">
        <DT ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="role_id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="user_id" nu="0">
        <DT ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="3" nm="fk_roles_users_roles" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="roles" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="roles_users" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="role_id" prCl="id"/>
      </Fk>
      <Fk deAc="0" nm="fk_roles_users_users" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="users" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="roles_users" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="user_id" prCl="id"/>
      </Fk>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="spatial_ref_sys">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="srid" nm="spatial_ref_sys_pkey"/>
      <Cl au="0" df="" nm="srid" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="auth_name" nu="1">
        <DT ds="VarChar" en="" id="12" ln="256" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="auth_srid" nu="1">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="srtext" nu="1">
        <DT ds="VarChar" en="" id="12" ln="2048" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="proj4text" nu="1">
        <DT ds="VarChar" en="" id="12" ln="2048" sc="null" sg="1" un="0"/>
      </Cl>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="typologies">
      <Cm>Tipologie tags</Cm>
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pktypologies"/>
      <Cl au="1" df="nextval('typolgies_id_seq'::regclass)" nm="id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="name" nu="0">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="description" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="typologies_paths">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pktypologies_paths"/>
      <Cl au="1" df="nextval('typologies_paths_id_seq'::regclass)" nm="id" nu="0">
        <DT ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="typology_id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="path_id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="3" nm="fk_typologies_paths_paths" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="paths" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="typologies_paths" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="path_id" prCl="id"/>
      </Fk>
      <Fk deAc="3" nm="fk_typologies_paths_typolgies" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="typologies" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="typologies_paths" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="typology_id" prCl="id"/>
      </Fk>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="typologies_pois">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pktypologies_pois"/>
      <Cl au="1" df="nextval('typologies_pois_id_seq'::regclass)" nm="id" nu="0">
        <DT ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="typology_id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="poi_id" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="3" nm="fk_typologies_pois_pois" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="pois" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="typologies_pois" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="poi_id" prCl="id"/>
      </Fk>
      <Fk deAc="3" nm="fk_typologies_pois_typologies" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="typologies" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="typologies_pois" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="typology_id" prCl="id"/>
      </Fk>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="user_datas">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pkuser_datas"/>
      <Cl au="1" df="nextval('user_datas_id_seq'::regclass)" nm="id" nu="0">
        <DT ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="user_id" nu="0">
        <DT ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="nome" nu="0">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="cognome" nu="0">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="luogo_nascita" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="data_nascita" nu="1">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="tel" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="cell" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_user_datas_users" prLkCl="id" upAc="3">
        <PrTb mn="0" nm="users" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="user_datas" oe="1" sch="public" zr="1"/>
        <ClPr cdCl="user_id" prCl="id"/>
      </Fk>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="users">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pkusers"/>
      <Cl au="1" df="nextval('users_id_seq'::regclass)" nm="id" nu="0">
        <DT ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="username" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="password" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="email" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="logins" nu="1">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="last_login" nu="1">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="data_ins" nu="0">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="data_mod" nu="0">
        <DT ds="VarChar" en="" id="12" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="data_first_change_password" nu="1">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="data_disabled" nu="1">
        <DT ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="false" nm="disabled" nu="0">
        <DT ds="Boolean" en="" id="16" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <SchTrHis/>
    </Tbl>
    <Proc nm="_st_asgeojson(integer, geography, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION _st_asgeojson(integer, geography, integer, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'geography_as_geojson'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="_st_asgeojson(integer, geometry, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION _st_asgeojson(integer, geometry, integer, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asGeoJson'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="_st_asgml(integer, geography, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION _st_asgml(integer, geography, integer, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'geography_as_gml'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="_st_asgml(integer, geometry, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION _st_asgml(integer, geometry, integer, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asGML'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="_st_askml(integer, geography, integer)">
      <src>CREATE OR REPLACE FUNCTION _st_askml(integer, geography, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'geography_as_kml'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="_st_askml(integer, geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION _st_askml(integer, geometry, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asKML'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="_st_bestsrid(geography)">
      <src>CREATE OR REPLACE FUNCTION _st_bestsrid(geography) 
  RETURNS integer AS 
$$SELECT _ST_BestSRID($1,$1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_bestsrid(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION _st_bestsrid(geography, geography) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'geography_bestsrid'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="_st_buffer(geometry, double precision, cstring)">
      <src>CREATE OR REPLACE FUNCTION _st_buffer(geometry, double precision, cstring) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'buffer'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_contains(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_contains(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'contains'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_containsproperly(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_containsproperly(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'containsproperly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_coveredby(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_coveredby(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'coveredby'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_covers(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION _st_covers(geography, geography) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'geography_covers'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_covers(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_covers(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'covers'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_crosses(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_crosses(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'crosses'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_dfullywithin(geometry, geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION _st_dfullywithin(geometry, geometry, double precision) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_dfullywithin'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="_st_distance(geography, geography, double precision, boolean)">
      <src>CREATE OR REPLACE FUNCTION _st_distance(geography, geography, double precision, boolean) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'geography_distance'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_dumppoints(the_geom geometry, cur_path integer[])">
      <src>CREATE OR REPLACE FUNCTION _st_dumppoints(the_geom geometry, cur_path integer[]) 
  RETURNS SETOF geometry_dump AS 
$$
DECLARE
  tmp geometry_dump;
  tmp2 geometry_dump;
  nb_points integer;
  nb_geom integer;
  i integer;
  j integer;
  g geometry;
  
BEGIN
  
  RAISE DEBUG '%,%', cur_path, ST_GeometryType(the_geom);

  -- Special case (MULTI* OR GEOMETRYCOLLECTION) : iterate and return the DumpPoints of the geometries
  SELECT ST_NumGeometries(the_geom) INTO nb_geom;

  IF (nb_geom IS NOT NULL) THEN
    
    i = 1;
    FOR tmp2 IN SELECT (ST_Dump(the_geom)).* LOOP

      FOR tmp IN SELECT * FROM _ST_DumpPoints(tmp2.geom, cur_path || tmp2.path) LOOP
	    RETURN NEXT tmp;
      END LOOP;
      i = i + 1;
      
    END LOOP;

    RETURN;
  END IF;
  

  -- Special case (POLYGON) : return the points of the rings of a polygon
  IF (ST_GeometryType(the_geom) = 'ST_Polygon') THEN

    FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_ExteriorRing(the_geom), cur_path || ARRAY[1]) LOOP
      RETURN NEXT tmp;
    END LOOP;
    
    j := ST_NumInteriorRings(the_geom);
    FOR i IN 1..j LOOP
        FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_InteriorRingN(the_geom, i), cur_path || ARRAY[i+1]) LOOP
          RETURN NEXT tmp;
        END LOOP;
    END LOOP;
    
    RETURN;
  END IF;

    
  -- Special case (POINT) : return the point
  IF (ST_GeometryType(the_geom) = 'ST_Point') THEN

    tmp.path = cur_path || ARRAY[1];
    tmp.geom = the_geom;

    RETURN NEXT tmp;
    RETURN;

  END IF;


  -- Use ST_NumPoints rather than ST_NPoints to have a NULL value if the_geom isn't
  -- a LINESTRING or CIRCULARSTRING.
  SELECT ST_NumPoints(the_geom) INTO nb_points;

  -- This should never happen
  IF (nb_points IS NULL) THEN
    RAISE EXCEPTION 'Unexpected error while dumping geometry %', ST_AsText(the_geom);
  END IF;

  FOR i IN 1..nb_points LOOP
    tmp.path = cur_path || ARRAY[i];
    tmp.geom := ST_PointN(the_geom, i);
    RETURN NEXT tmp;
  END LOOP;
   
END
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100
  ROWS 1000;</src>
    </Proc>
    <Proc nm="_st_dwithin(geography, geography, double precision, boolean)">
      <src>CREATE OR REPLACE FUNCTION _st_dwithin(geography, geography, double precision, boolean) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'geography_dwithin'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_dwithin(geometry, geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION _st_dwithin(geometry, geometry, double precision) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_dwithin'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_equals(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_equals(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'geomequals'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_expand(geography, double precision)">
      <src>CREATE OR REPLACE FUNCTION _st_expand(geography, double precision) 
  RETURNS geography AS 
$$'$libdir/postgis-1.5', 'geography_expand'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="_st_intersects(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_intersects(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'intersects'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_linecrossingdirection(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_linecrossingdirection(geometry, geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'ST_LineCrossingDirection'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_longestline(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_longestline(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_longestline2d'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="_st_maxdistance(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_maxdistance(geometry, geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_maxdistance2d_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="_st_orderingequals(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_orderingequals(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_same'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_overlaps(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_overlaps(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'overlaps'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_pointoutside(geography)">
      <src>CREATE OR REPLACE FUNCTION _st_pointoutside(geography) 
  RETURNS geography AS 
$$'$libdir/postgis-1.5', 'geography_point_outside'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="_st_touches(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_touches(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'touches'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="_st_within(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION _st_within(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'within'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="accum(geometry)">
      <src>CREATE OR REPLACE FUNCTION accum(geometry) 
  RETURNS geometry[] AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="addauth(text)">
      <src>CREATE OR REPLACE FUNCTION addauth(text) 
  RETURNS boolean AS 
$$ 
DECLARE
	lockid alias for $1;
	okay boolean;
	myrec record;
BEGIN
	-- check to see if table exists
	--  if not, CREATE TEMP TABLE mylock (transid xid, lockcode text)
	okay := 'f';
	FOR myrec IN SELECT * FROM pg_class WHERE relname = 'temp_lock_have_table' LOOP
		okay := 't';
	END LOOP; 
	IF (okay &lt;&gt; 't') THEN 
		CREATE TEMP TABLE temp_lock_have_table (transid xid, lockcode text);
			-- this will only work from pgsql7.4 up
			-- ON COMMIT DELETE ROWS;
	END IF;

	--  INSERT INTO mylock VALUES ( $1)
--	EXECUTE 'INSERT INTO temp_lock_have_table VALUES ( '||
--		quote_literal(getTransactionID()) || ',' ||
--		quote_literal(lockid) ||')';

	INSERT INTO temp_lock_have_table VALUES (getTransactionID(), lockid);

	RETURN true::boolean;
END;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="addbbox(geometry)">
      <src>CREATE OR REPLACE FUNCTION addbbox(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_addBBOX'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="addgeometrycolumn(character varying, character varying, character varying, character varying, integer, character varying, integer)">
      <src>CREATE OR REPLACE FUNCTION addgeometrycolumn(character varying, character varying, character varying, character varying, integer, character varying, integer) 
  RETURNS text AS 
$$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	column_name alias for $4;
	new_srid alias for $5;
	new_type alias for $6;
	new_dim alias for $7;
	rec RECORD;
	sr varchar;
	real_schema name;
	sql text;

BEGIN

	-- Verify geometry type
	IF ( NOT ( (new_type = 'GEOMETRY') OR
			   (new_type = 'GEOMETRYCOLLECTION') OR
			   (new_type = 'POINT') OR
			   (new_type = 'MULTIPOINT') OR
			   (new_type = 'POLYGON') OR
			   (new_type = 'MULTIPOLYGON') OR
			   (new_type = 'LINESTRING') OR
			   (new_type = 'MULTILINESTRING') OR
			   (new_type = 'GEOMETRYCOLLECTIONM') OR
			   (new_type = 'POINTM') OR
			   (new_type = 'MULTIPOINTM') OR
			   (new_type = 'POLYGONM') OR
			   (new_type = 'MULTIPOLYGONM') OR
			   (new_type = 'LINESTRINGM') OR
			   (new_type = 'MULTILINESTRINGM') OR
			   (new_type = 'CIRCULARSTRING') OR
			   (new_type = 'CIRCULARSTRINGM') OR
			   (new_type = 'COMPOUNDCURVE') OR
			   (new_type = 'COMPOUNDCURVEM') OR
			   (new_type = 'CURVEPOLYGON') OR
			   (new_type = 'CURVEPOLYGONM') OR
			   (new_type = 'MULTICURVE') OR
			   (new_type = 'MULTICURVEM') OR
			   (new_type = 'MULTISURFACE') OR
			   (new_type = 'MULTISURFACEM')) )
	THEN
		RAISE EXCEPTION 'Invalid type name - valid ones are:
	POINT, MULTIPOINT,
	LINESTRING, MULTILINESTRING,
	POLYGON, MULTIPOLYGON,
	CIRCULARSTRING, COMPOUNDCURVE, MULTICURVE,
	CURVEPOLYGON, MULTISURFACE,
	GEOMETRY, GEOMETRYCOLLECTION,
	POINTM, MULTIPOINTM,
	LINESTRINGM, MULTILINESTRINGM,
	POLYGONM, MULTIPOLYGONM,
	CIRCULARSTRINGM, COMPOUNDCURVEM, MULTICURVEM
	CURVEPOLYGONM, MULTISURFACEM,
	or GEOMETRYCOLLECTIONM';
		RETURN 'fail';
	END IF;


	-- Verify dimension
	IF ( (new_dim &gt;4) OR (new_dim &lt;0) ) THEN
		RAISE EXCEPTION 'invalid dimension';
		RETURN 'fail';
	END IF;

	IF ( (new_type LIKE '%M') AND (new_dim!=3) ) THEN
		RAISE EXCEPTION 'TypeM needs 3 dimensions';
		RETURN 'fail';
	END IF;


	-- Verify SRID
	IF ( new_srid != -1 ) THEN
		SELECT SRID INTO sr FROM spatial_ref_sys WHERE SRID = new_srid;
		IF NOT FOUND THEN
			RAISE EXCEPTION 'AddGeometryColumns() - invalid SRID';
			RETURN 'fail';
		END IF;
	END IF;


	-- Verify schema
	IF ( schema_name IS NOT NULL AND schema_name != '' ) THEN
		sql := 'SELECT nspname FROM pg_namespace ' ||
			'WHERE text(nspname) = ' || quote_literal(schema_name) ||
			'LIMIT 1';
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Schema % is not a valid schemaname', quote_literal(schema_name);
			RETURN 'fail';
		END IF;
	END IF;

	IF ( real_schema IS NULL ) THEN
		RAISE DEBUG 'Detecting schema';
		sql := 'SELECT n.nspname AS schemaname ' ||
			'FROM pg_catalog.pg_class c ' ||
			  'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace ' ||
			'WHERE c.relkind = ' || quote_literal('r') ||
			' AND n.nspname NOT IN (' || quote_literal('pg_catalog') || ', ' || quote_literal('pg_toast') || ')' ||
			' AND pg_catalog.pg_table_is_visible(c.oid)' ||
			' AND c.relname = ' || quote_literal(table_name);
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Table % does not occur in the search_path', quote_literal(table_name);
			RETURN 'fail';
		END IF;
	END IF;


	-- Add geometry column to table
	sql := 'ALTER TABLE ' ||
		quote_ident(real_schema) || '.' || quote_ident(table_name)
		|| ' ADD COLUMN ' || quote_ident(column_name) ||
		' geometry ';
	RAISE DEBUG '%', sql;
	EXECUTE sql;


	-- Delete stale record in geometry_columns (if any)
	sql := 'DELETE FROM geometry_columns WHERE
		f_table_catalog = ' || quote_literal('') ||
		' AND f_table_schema = ' ||
		quote_literal(real_schema) ||
		' AND f_table_name = ' || quote_literal(table_name) ||
		' AND f_geometry_column = ' || quote_literal(column_name);
	RAISE DEBUG '%', sql;
	EXECUTE sql;


	-- Add record in geometry_columns
	sql := 'INSERT INTO geometry_columns (f_table_catalog,f_table_schema,f_table_name,' ||
										  'f_geometry_column,coord_dimension,srid,type)' ||
		' VALUES (' ||
		quote_literal('') || ',' ||
		quote_literal(real_schema) || ',' ||
		quote_literal(table_name) || ',' ||
		quote_literal(column_name) || ',' ||
		new_dim::text || ',' ||
		new_srid::text || ',' ||
		quote_literal(new_type) || ')';
	RAISE DEBUG '%', sql;
	EXECUTE sql;


	-- Add table CHECKs
	sql := 'ALTER TABLE ' ||
		quote_ident(real_schema) || '.' || quote_ident(table_name)
		|| ' ADD CONSTRAINT '
		|| quote_ident('enforce_srid_' || column_name)
		|| ' CHECK (ST_SRID(' || quote_ident(column_name) ||
		') = ' || new_srid::text || ')' ;
	RAISE DEBUG '%', sql;
	EXECUTE sql;

	sql := 'ALTER TABLE ' ||
		quote_ident(real_schema) || '.' || quote_ident(table_name)
		|| ' ADD CONSTRAINT '
		|| quote_ident('enforce_dims_' || column_name)
		|| ' CHECK (ST_NDims(' || quote_ident(column_name) ||
		') = ' || new_dim::text || ')' ;
	RAISE DEBUG '%', sql;
	EXECUTE sql;

	IF ( NOT (new_type = 'GEOMETRY')) THEN
		sql := 'ALTER TABLE ' ||
			quote_ident(real_schema) || '.' || quote_ident(table_name) || ' ADD CONSTRAINT ' ||
			quote_ident('enforce_geotype_' || column_name) ||
			' CHECK (GeometryType(' ||
			quote_ident(column_name) || ')=' ||
			quote_literal(new_type) || ' OR (' ||
			quote_ident(column_name) || ') is null)';
		RAISE DEBUG '%', sql;
		EXECUTE sql;
	END IF;

	RETURN
		real_schema || '.' ||
		table_name || '.' || column_name ||
		' SRID:' || new_srid::text ||
		' TYPE:' || new_type ||
		' DIMS:' || new_dim::text || ' ';
END;
$$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer)">
      <src>CREATE OR REPLACE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) 
  RETURNS text AS 
$$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$$
  LANGUAGE plpgsql STABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="addgeometrycolumn(character varying, character varying, integer, character varying, integer)">
      <src>CREATE OR REPLACE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) 
  RETURNS text AS 
$$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="addpoint(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION addpoint(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_addpoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="addpoint(geometry, geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION addpoint(geometry, geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_addpoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1,  $2, $3, 0,  $4, $5, 0,  0, 0, 1,  $6, $7, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_affine'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="area(geometry)">
      <src>CREATE OR REPLACE FUNCTION area(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_area_polygon'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="area2d(geometry)">
      <src>CREATE OR REPLACE FUNCTION area2d(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_area_polygon'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="asbinary(geometry)">
      <src>CREATE OR REPLACE FUNCTION asbinary(geometry) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asBinary'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="asbinary(geometry, text)">
      <src>CREATE OR REPLACE FUNCTION asbinary(geometry, text) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asBinary'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="asewkb(geometry)">
      <src>CREATE OR REPLACE FUNCTION asewkb(geometry) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'WKBFromLWGEOM'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="asewkb(geometry, text)">
      <src>CREATE OR REPLACE FUNCTION asewkb(geometry, text) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'WKBFromLWGEOM'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="asewkt(geometry)">
      <src>CREATE OR REPLACE FUNCTION asewkt(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asEWKT'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="asgml(geometry)">
      <src>CREATE OR REPLACE FUNCTION asgml(geometry) 
  RETURNS text AS 
$$SELECT _ST_AsGML(2, $1, 15, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="asgml(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION asgml(geometry, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGML(2, $1, $2, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="ashexewkb(geometry)">
      <src>CREATE OR REPLACE FUNCTION ashexewkb(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asHEXEWKB'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="ashexewkb(geometry, text)">
      <src>CREATE OR REPLACE FUNCTION ashexewkb(geometry, text) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asHEXEWKB'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="askml(geometry)">
      <src>CREATE OR REPLACE FUNCTION askml(geometry) 
  RETURNS text AS 
$$SELECT _ST_AsKML(2, transform($1,4326), 15)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="askml(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION askml(geometry, integer) 
  RETURNS text AS 
$$SELECT _ST_AsKML(2, transform($1,4326), $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="askml(integer, geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION askml(integer, geometry, integer) 
  RETURNS text AS 
$$SELECT _ST_AsKML($1, transform($2,4326), $3)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="assvg(geometry)">
      <src>CREATE OR REPLACE FUNCTION assvg(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'assvg_geometry'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="assvg(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION assvg(geometry, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'assvg_geometry'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="assvg(geometry, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION assvg(geometry, integer, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'assvg_geometry'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="astext(geometry)">
      <src>CREATE OR REPLACE FUNCTION astext(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asText'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="azimuth(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION azimuth(geometry, geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_azimuth'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="bdmpolyfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION bdmpolyfromtext(text, integer) 
  RETURNS geometry AS 
$$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$$
  LANGUAGE plpgsql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="bdpolyfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION bdpolyfromtext(text, integer) 
  RETURNS geometry AS 
$$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$$
  LANGUAGE plpgsql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="boundary(geometry)">
      <src>CREATE OR REPLACE FUNCTION boundary(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'boundary'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box(box3d)">
      <src>CREATE OR REPLACE FUNCTION box(box3d) 
  RETURNS box AS 
$$'$libdir/postgis-1.5', 'BOX3D_to_BOX'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box(geometry)">
      <src>CREATE OR REPLACE FUNCTION box(geometry) 
  RETURNS box AS 
$$'$libdir/postgis-1.5', 'LWGEOM_to_BOX'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box2d(box3d)">
      <src>CREATE OR REPLACE FUNCTION box2d(box3d) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'BOX3D_to_BOX2DFLOAT4'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box2d(box3d_extent)">
      <src>CREATE OR REPLACE FUNCTION box2d(box3d_extent) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'BOX3D_to_BOX2DFLOAT4'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box2d(geometry)">
      <src>CREATE OR REPLACE FUNCTION box2d(geometry) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'LWGEOM_to_BOX2DFLOAT4'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box2d_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION box2d_in(cstring) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box2d_out(box2d)">
      <src>CREATE OR REPLACE FUNCTION box2d_out(box2d) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box3d(box2d)">
      <src>CREATE OR REPLACE FUNCTION box3d(box2d) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_to_BOX3D'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box3d(geometry)">
      <src>CREATE OR REPLACE FUNCTION box3d(geometry) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'LWGEOM_to_BOX3D'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box3d_extent(box3d_extent)">
      <src>CREATE OR REPLACE FUNCTION box3d_extent(box3d_extent) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'BOX3D_extent_to_BOX3D'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box3d_extent_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION box3d_extent_in(cstring) 
  RETURNS box3d_extent AS 
$$'$libdir/postgis-1.5', 'BOX3D_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box3d_extent_out(box3d_extent)">
      <src>CREATE OR REPLACE FUNCTION box3d_extent_out(box3d_extent) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'BOX3D_extent_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box3d_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION box3d_in(cstring) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'BOX3D_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box3d_out(box3d)">
      <src>CREATE OR REPLACE FUNCTION box3d_out(box3d) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'BOX3D_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="box3dtobox(box3d)">
      <src>CREATE OR REPLACE FUNCTION box3dtobox(box3d) 
  RETURNS box AS 
$$SELECT box($1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="buffer(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION buffer(geometry, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'buffer'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="buffer(geometry, double precision, integer)">
      <src>CREATE OR REPLACE FUNCTION buffer(geometry, double precision, integer) 
  RETURNS geometry AS 
$$SELECT ST_Buffer($1, $2, $3)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="buildarea(geometry)">
      <src>CREATE OR REPLACE FUNCTION buildarea(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_buildarea'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="bytea(geometry)">
      <src>CREATE OR REPLACE FUNCTION bytea(geometry) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'LWGEOM_to_bytea'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="centroid(geometry)">
      <src>CREATE OR REPLACE FUNCTION centroid(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'centroid'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="checkauth(text, text)">
      <src>CREATE OR REPLACE FUNCTION checkauth(text, text) 
  RETURNS integer AS 
$$ SELECT CheckAuth('', $1, $2) $$
  LANGUAGE sql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="checkauth(text, text, text)">
      <src>CREATE OR REPLACE FUNCTION checkauth(text, text, text) 
  RETURNS integer AS 
$$ 
DECLARE
	schema text;
BEGIN
	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	if ( $1 != '' ) THEN
		schema = $1;
	ELSE
		SELECT current_schema() into schema;
	END IF;

	-- TODO: check for an already existing trigger ?

	EXECUTE 'CREATE TRIGGER check_auth BEFORE UPDATE OR DELETE ON ' 
		|| quote_ident(schema) || '.' || quote_ident($2)
		||' FOR EACH ROW EXECUTE PROCEDURE CheckAuthTrigger('
		|| quote_literal($3) || ')';

	RETURN 0;
END;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="checkauthtrigger()">
      <src>CREATE OR REPLACE FUNCTION checkauthtrigger() 
  RETURNS trigger AS 
$$'$libdir/postgis-1.5', 'check_authorization'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="chip_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION chip_in(cstring) 
  RETURNS chip AS 
$$'$libdir/postgis-1.5', 'CHIP_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="chip_out(chip)">
      <src>CREATE OR REPLACE FUNCTION chip_out(chip) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'CHIP_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="collect(geometry)">
      <src>CREATE OR REPLACE FUNCTION collect(geometry) 
  RETURNS geometry AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="collect(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION collect(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_collect'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="combine_bbox(box2d, geometry)">
      <src>CREATE OR REPLACE FUNCTION combine_bbox(box2d, geometry) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_combine'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="combine_bbox(box3d, geometry)">
      <src>CREATE OR REPLACE FUNCTION combine_bbox(box3d, geometry) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'BOX3D_combine'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="combine_bbox(box3d_extent, geometry)">
      <src>CREATE OR REPLACE FUNCTION combine_bbox(box3d_extent, geometry) 
  RETURNS box3d_extent AS 
$$'$libdir/postgis-1.5', 'BOX3D_combine'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="compression(chip)">
      <src>CREATE OR REPLACE FUNCTION compression(chip) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'CHIP_getCompression'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="contains(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION contains(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'contains'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="convexhull(geometry)">
      <src>CREATE OR REPLACE FUNCTION convexhull(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'convexhull'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="crosses(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION crosses(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'crosses'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="datatype(chip)">
      <src>CREATE OR REPLACE FUNCTION datatype(chip) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'CHIP_getDatatype'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="difference(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION difference(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'difference'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="dimension(geometry)">
      <src>CREATE OR REPLACE FUNCTION dimension(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_dimension'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="disablelongtransactions()">
      <src>CREATE OR REPLACE FUNCTION disablelongtransactions() 
  RETURNS text AS 
$$ 
DECLARE
	rec RECORD;

BEGIN

	--
	-- Drop all triggers applied by CheckAuth()
	--
	FOR rec IN
		SELECT c.relname, t.tgname, t.tgargs FROM pg_trigger t, pg_class c, pg_proc p
		WHERE p.proname = 'checkauthtrigger' and t.tgfoid = p.oid and t.tgrelid = c.oid
	LOOP
		EXECUTE 'DROP TRIGGER ' || quote_ident(rec.tgname) ||
			' ON ' || quote_ident(rec.relname);
	END LOOP;

	--
	-- Drop the authorization_table table
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table' LOOP
		DROP TABLE authorization_table;
	END LOOP;

	--
	-- Drop the authorized_tables view
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables' LOOP
		DROP VIEW authorized_tables;
	END LOOP;

	RETURN 'Long transactions support disabled';
END;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="disjoint(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION disjoint(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'disjoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="distance(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION distance(geometry, geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_mindistance2d'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="distance_sphere(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION distance_sphere(geometry, geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_distance_sphere'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="distance_spheroid(geometry, geometry, spheroid)">
      <src>CREATE OR REPLACE FUNCTION distance_spheroid(geometry, geometry, spheroid) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_distance_ellipsoid'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="dropbbox(geometry)">
      <src>CREATE OR REPLACE FUNCTION dropbbox(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_dropBBOX'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="dropgeometrycolumn(character varying, character varying)">
      <src>CREATE OR REPLACE FUNCTION dropgeometrycolumn(character varying, character varying) 
  RETURNS text AS 
$$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="dropgeometrycolumn(character varying, character varying, character varying)">
      <src>CREATE OR REPLACE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) 
  RETURNS text AS 
$$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="dropgeometrycolumn(character varying, character varying, character varying, character varying)">
      <src>CREATE OR REPLACE FUNCTION dropgeometrycolumn(character varying, character varying, character varying, character varying) 
  RETURNS text AS 
$$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	column_name alias for $4;
	myrec RECORD;
	okay boolean;
	real_schema name;

BEGIN


	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = 'f';

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := 't';
		END LOOP;

		IF ( okay &lt;&gt; 't' ) THEN
			RAISE NOTICE 'Invalid schema name - using current_schema()';
			SELECT current_schema() into real_schema;
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT current_schema() into real_schema;
	END IF;

	-- Find out if the column is in the geometry_columns table
	okay = 'f';
	FOR myrec IN SELECT * from geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := 't';
	END LOOP;
	IF (okay &lt;&gt; 't') THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN 'f';
	END IF;

	-- Remove ref from geometry_columns table
	EXECUTE 'delete from geometry_columns where f_table_schema = ' ||
		quote_literal(real_schema) || ' and f_table_name = ' ||
		quote_literal(table_name)  || ' and f_geometry_column = ' ||
		quote_literal(column_name);

	-- Remove table column
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' DROP COLUMN ' ||
		quote_ident(column_name);

	RETURN real_schema || '.' || table_name || '.' || column_name ||' effectively removed.';

END;
$$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="dropgeometrytable(character varying)">
      <src>CREATE OR REPLACE FUNCTION dropgeometrytable(character varying) 
  RETURNS text AS 
$$ SELECT DropGeometryTable('','',$1) $$
  LANGUAGE sql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="dropgeometrytable(character varying, character varying)">
      <src>CREATE OR REPLACE FUNCTION dropgeometrytable(character varying, character varying) 
  RETURNS text AS 
$$ SELECT DropGeometryTable('',$1,$2) $$
  LANGUAGE sql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="dropgeometrytable(character varying, character varying, character varying)">
      <src>CREATE OR REPLACE FUNCTION dropgeometrytable(character varying, character varying, character varying) 
  RETURNS text AS 
$$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	real_schema name;

BEGIN

	IF ( schema_name = '' ) THEN
		SELECT current_schema() into real_schema;
	ELSE
		real_schema = schema_name;
	END IF;

	-- Remove refs from geometry_columns table
	EXECUTE 'DELETE FROM geometry_columns WHERE ' ||
		'f_table_schema = ' || quote_literal(real_schema) ||
		' AND ' ||
		' f_table_name = ' || quote_literal(table_name);

	-- Remove table
	EXECUTE 'DROP TABLE '
		|| quote_ident(real_schema) || '.' ||
		quote_ident(table_name);

	RETURN
		real_schema || '.' ||
		table_name ||' dropped.';

END;
$$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="dump(geometry)">
      <src>CREATE OR REPLACE FUNCTION dump(geometry) 
  RETURNS SETOF geometry_dump AS 
$$'$libdir/postgis-1.5', 'LWGEOM_dump'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1
  ROWS 1000;</src>
    </Proc>
    <Proc nm="dumprings(geometry)">
      <src>CREATE OR REPLACE FUNCTION dumprings(geometry) 
  RETURNS SETOF geometry_dump AS 
$$'$libdir/postgis-1.5', 'LWGEOM_dump_rings'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1
  ROWS 1000;</src>
    </Proc>
    <Proc nm="enablelongtransactions()">
      <src>CREATE OR REPLACE FUNCTION enablelongtransactions() 
  RETURNS text AS 
$$ 
DECLARE
	"query" text;
	exists bool;
	rec RECORD;

BEGIN

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists
	THEN
		"query" = 'CREATE TABLE authorization_table (
			toid oid, -- table oid
			rid text, -- row id
			expires timestamp,
			authid text
		)';
		EXECUTE "query";
	END IF;

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists THEN
		"query" = 'CREATE VIEW authorized_tables AS ' ||
			'SELECT ' ||
			'n.nspname as schema, ' ||
			'c.relname as table, trim(' ||
			quote_literal(chr(92) || '000') ||
			' from t.tgargs) as id_column ' ||
			'FROM pg_trigger t, pg_class c, pg_proc p ' ||
			', pg_namespace n ' ||
			'WHERE p.proname = ' || quote_literal('checkauthtrigger') ||
			' AND c.relnamespace = n.oid' ||
			' AND t.tgfoid = p.oid and t.tgrelid = c.oid';
		EXECUTE "query";
	END IF;

	RETURN 'Long transactions support enabled';
END;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="endpoint(geometry)">
      <src>CREATE OR REPLACE FUNCTION endpoint(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_endpoint_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="envelope(geometry)">
      <src>CREATE OR REPLACE FUNCTION envelope(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_envelope'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="equals(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION equals(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'geomequals'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="estimated_extent(text, text)">
      <src>CREATE OR REPLACE FUNCTION estimated_extent(text, text) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'LWGEOM_estimated_extent'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="estimated_extent(text, text, text)">
      <src>CREATE OR REPLACE FUNCTION estimated_extent(text, text, text) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'LWGEOM_estimated_extent'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="expand(box2d, double precision)">
      <src>CREATE OR REPLACE FUNCTION expand(box2d, double precision) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_expand'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="expand(box3d, double precision)">
      <src>CREATE OR REPLACE FUNCTION expand(box3d, double precision) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'BOX3D_expand'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="expand(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION expand(geometry, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_expand'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="extent(geometry)">
      <src>CREATE OR REPLACE FUNCTION extent(geometry) 
  RETURNS box3d_extent AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="extent3d(geometry)">
      <src>CREATE OR REPLACE FUNCTION extent3d(geometry) 
  RETURNS box3d AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="exteriorring(geometry)">
      <src>CREATE OR REPLACE FUNCTION exteriorring(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_exteriorring_polygon'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="factor(chip)">
      <src>CREATE OR REPLACE FUNCTION factor(chip) 
  RETURNS real AS 
$$'$libdir/postgis-1.5', 'CHIP_getFactor'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="find_extent(text, text)">
      <src>CREATE OR REPLACE FUNCTION find_extent(text, text) 
  RETURNS box2d AS 
$$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent("' || columnname || '") FROM "' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$$
  LANGUAGE plpgsql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="find_extent(text, text, text)">
      <src>CREATE OR REPLACE FUNCTION find_extent(text, text, text) 
  RETURNS box2d AS 
$$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent("' || columnname || '") FROM "' || schemaname || '"."' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$$
  LANGUAGE plpgsql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="find_srid(character varying, character varying, character varying)">
      <src>CREATE OR REPLACE FUNCTION find_srid(character varying, character varying, character varying) 
  RETURNS integer AS 
$$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$$
  LANGUAGE plpgsql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="fix_geometry_columns()">
      <src>CREATE OR REPLACE FUNCTION fix_geometry_columns() 
  RETURNS text AS 
$$
DECLARE
	mislinked record;
	result text;
	linked integer;
	deleted integer;
	foundschema integer;
BEGIN

	-- Since 7.3 schema support has been added.
	-- Previous postgis versions used to put the database name in
	-- the schema column. This needs to be fixed, so we try to
	-- set the correct schema for each geometry_colums record
	-- looking at table, column, type and srid.
	UPDATE geometry_columns SET f_table_schema = n.nspname
		FROM pg_namespace n, pg_class c, pg_attribute a,
			pg_constraint sridcheck, pg_constraint typecheck
			WHERE ( f_table_schema is NULL
		OR f_table_schema = ''
			OR f_table_schema NOT IN (
					SELECT nspname::varchar
					FROM pg_namespace nn, pg_class cc, pg_attribute aa
					WHERE cc.relnamespace = nn.oid
					AND cc.relname = f_table_name::name
					AND aa.attrelid = cc.oid
					AND aa.attname = f_geometry_column::name))
			AND f_table_name::name = c.relname
			AND c.oid = a.attrelid
			AND c.relnamespace = n.oid
			AND f_geometry_column::name = a.attname

			AND sridcheck.conrelid = c.oid
		AND sridcheck.consrc LIKE '(srid(% = %)'
			AND sridcheck.consrc ~ textcat(' = ', srid::text)

			AND typecheck.conrelid = c.oid
		AND typecheck.consrc LIKE
		'((geometrytype(%) = ''%''::text) OR (% IS NULL))'
			AND typecheck.consrc ~ textcat(' = ''', type::text)

			AND NOT EXISTS (
					SELECT oid FROM geometry_columns gc
					WHERE c.relname::varchar = gc.f_table_name
					AND n.nspname::varchar = gc.f_table_schema
					AND a.attname::varchar = gc.f_geometry_column
			);

	GET DIAGNOSTICS foundschema = ROW_COUNT;

	-- no linkage to system table needed
	return 'fixed:'||foundschema::text;

END;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="force_2d(geometry)">
      <src>CREATE OR REPLACE FUNCTION force_2d(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_2d'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="force_3d(geometry)">
      <src>CREATE OR REPLACE FUNCTION force_3d(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_3dz'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="force_3dm(geometry)">
      <src>CREATE OR REPLACE FUNCTION force_3dm(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_3dm'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="force_3dz(geometry)">
      <src>CREATE OR REPLACE FUNCTION force_3dz(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_3dz'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="force_4d(geometry)">
      <src>CREATE OR REPLACE FUNCTION force_4d(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_4d'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="force_collection(geometry)">
      <src>CREATE OR REPLACE FUNCTION force_collection(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_collection'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="forcerhr(geometry)">
      <src>CREATE OR REPLACE FUNCTION forcerhr(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_forceRHR_poly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography(geography, integer, boolean)">
      <src>CREATE OR REPLACE FUNCTION geography(geography, integer, boolean) 
  RETURNS geography AS 
$$'$libdir/postgis-1.5', 'geography_enforce_typmod'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography(geometry)">
      <src>CREATE OR REPLACE FUNCTION geography(geometry) 
  RETURNS geography AS 
$$'$libdir/postgis-1.5', 'geography_from_geometry'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_analyze(internal)">
      <src>CREATE OR REPLACE FUNCTION geography_analyze(internal) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'geography_analyze'$$
  LANGUAGE c VOLATILE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_cmp(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION geography_cmp(geography, geography) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'geography_cmp'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_eq(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION geography_eq(geography, geography) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'geography_eq'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_ge(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION geography_ge(geography, geography) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'geography_ge'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_gist_compress(internal)">
      <src>CREATE OR REPLACE FUNCTION geography_gist_compress(internal) 
  RETURNS internal AS 
$$'$libdir/postgis-1.5', 'geography_gist_compress'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="geography_gist_consistent(internal, geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION geography_gist_consistent(internal, geometry, integer) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'geography_gist_consistent'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="geography_gist_decompress(internal)">
      <src>CREATE OR REPLACE FUNCTION geography_gist_decompress(internal) 
  RETURNS internal AS 
$$'$libdir/postgis-1.5', 'geography_gist_decompress'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="geography_gist_join_selectivity(internal, oid, internal, smallint)">
      <src>CREATE OR REPLACE FUNCTION geography_gist_join_selectivity(internal, oid, internal, smallint) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'geography_gist_join_selectivity'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="geography_gist_penalty(internal, internal, internal)">
      <src>CREATE OR REPLACE FUNCTION geography_gist_penalty(internal, internal, internal) 
  RETURNS internal AS 
$$'$libdir/postgis-1.5', 'geography_gist_penalty'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="geography_gist_picksplit(internal, internal)">
      <src>CREATE OR REPLACE FUNCTION geography_gist_picksplit(internal, internal) 
  RETURNS internal AS 
$$'$libdir/postgis-1.5', 'geography_gist_picksplit'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="geography_gist_same(box2d, box2d, internal)">
      <src>CREATE OR REPLACE FUNCTION geography_gist_same(box2d, box2d, internal) 
  RETURNS internal AS 
$$'$libdir/postgis-1.5', 'geography_gist_same'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="geography_gist_selectivity(internal, oid, internal, integer)">
      <src>CREATE OR REPLACE FUNCTION geography_gist_selectivity(internal, oid, internal, integer) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'geography_gist_selectivity'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="geography_gist_union(bytea, internal)">
      <src>CREATE OR REPLACE FUNCTION geography_gist_union(bytea, internal) 
  RETURNS internal AS 
$$'$libdir/postgis-1.5', 'geography_gist_union'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="geography_gt(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION geography_gt(geography, geography) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'geography_gt'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_in(cstring, oid, integer)">
      <src>CREATE OR REPLACE FUNCTION geography_in(cstring, oid, integer) 
  RETURNS geography AS 
$$'$libdir/postgis-1.5', 'geography_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_le(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION geography_le(geography, geography) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'geography_le'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_lt(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION geography_lt(geography, geography) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'geography_lt'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_out(geography)">
      <src>CREATE OR REPLACE FUNCTION geography_out(geography) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'geography_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_overlaps(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION geography_overlaps(geography, geography) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'geography_overlaps'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_typmod_dims(integer)">
      <src>CREATE OR REPLACE FUNCTION geography_typmod_dims(integer) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'geography_typmod_dims'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_typmod_in(cstring[])">
      <src>CREATE OR REPLACE FUNCTION geography_typmod_in(cstring[]) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'geography_typmod_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_typmod_out(integer)">
      <src>CREATE OR REPLACE FUNCTION geography_typmod_out(integer) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'geography_typmod_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_typmod_srid(integer)">
      <src>CREATE OR REPLACE FUNCTION geography_typmod_srid(integer) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'geography_typmod_srid'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geography_typmod_type(integer)">
      <src>CREATE OR REPLACE FUNCTION geography_typmod_type(integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'geography_typmod_type'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geomcollfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION geomcollfromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE
	WHEN geometrytype(GeomFromText($1)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="geomcollfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION geomcollfromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE
	WHEN geometrytype(GeomFromText($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="geomcollfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION geomcollfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE
	WHEN geometrytype(GeomFromWKB($1)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="geomcollfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION geomcollfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE
	WHEN geometrytype(GeomFromWKB($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="geometry(box2d)">
      <src>CREATE OR REPLACE FUNCTION geometry(box2d) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_to_LWGEOM'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry(box3d)">
      <src>CREATE OR REPLACE FUNCTION geometry(box3d) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'BOX3D_to_LWGEOM'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry(box3d_extent)">
      <src>CREATE OR REPLACE FUNCTION geometry(box3d_extent) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'BOX3D_to_LWGEOM'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry(bytea)">
      <src>CREATE OR REPLACE FUNCTION geometry(bytea) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_from_bytea'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry(chip)">
      <src>CREATE OR REPLACE FUNCTION geometry(chip) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'CHIP_to_LWGEOM'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry(geography)">
      <src>CREATE OR REPLACE FUNCTION geometry(geography) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'geometry_from_geography'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry(text)">
      <src>CREATE OR REPLACE FUNCTION geometry(text) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'parse_WKT_lwgeom'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_above(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_above(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_above'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_analyze(internal)">
      <src>CREATE OR REPLACE FUNCTION geometry_analyze(internal) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_analyze'$$
  LANGUAGE c VOLATILE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_below(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_below(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_below'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_cmp(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_cmp(geometry, geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'lwgeom_cmp'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_contain(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_contain(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_contain'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_contained(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_contained(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_contained'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_eq(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_eq(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'lwgeom_eq'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_ge(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_ge(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'lwgeom_ge'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_gist_joinsel(internal, oid, internal, smallint)">
      <src>CREATE OR REPLACE FUNCTION geometry_gist_joinsel(internal, oid, internal, smallint) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_joinsel'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_gist_sel(internal, oid, internal, integer)">
      <src>CREATE OR REPLACE FUNCTION geometry_gist_sel(internal, oid, internal, integer) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_sel'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_gt(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_gt(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'lwgeom_gt'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION geometry_in(cstring) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_le(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_le(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'lwgeom_le'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_left(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_left(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_left'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_lt(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_lt(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'lwgeom_lt'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_out(geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_out(geometry) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'LWGEOM_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_overabove(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_overabove(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_overabove'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_overbelow(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_overbelow(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_overbelow'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_overlap(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_overlap(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_overlap'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_overleft(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_overleft(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_overleft'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_overright(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_overright(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_overright'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_recv(internal)">
      <src>CREATE OR REPLACE FUNCTION geometry_recv(internal) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_recv'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_right(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_right(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_right'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_same(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_same(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_samebox'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_samebox(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_samebox(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_samebox'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometry_send(geometry)">
      <src>CREATE OR REPLACE FUNCTION geometry_send(geometry) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'LWGEOM_send'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometryfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION geometryfromtext(text) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_from_text'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometryfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION geometryfromtext(text, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_from_text'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometryn(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION geometryn(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_geometryn_collection'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geometrytype(geometry)">
      <src>CREATE OR REPLACE FUNCTION geometrytype(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_getTYPE'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geomfromewkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION geomfromewkb(bytea) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOMFromWKB'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geomfromewkt(text)">
      <src>CREATE OR REPLACE FUNCTION geomfromewkt(text) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'parse_WKT_lwgeom'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geomfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION geomfromtext(text) 
  RETURNS geometry AS 
$$SELECT geometryfromtext($1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="geomfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION geomfromtext(text, integer) 
  RETURNS geometry AS 
$$SELECT geometryfromtext($1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="geomfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION geomfromwkb(bytea) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_from_WKB'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="geomfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION geomfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$SELECT setSRID(GeomFromWKB($1), $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="geomunion(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION geomunion(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'geomunion'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="get_proj4_from_srid(integer)">
      <src>CREATE OR REPLACE FUNCTION get_proj4_from_srid(integer) 
  RETURNS text AS 
$$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$$
  LANGUAGE plpgsql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="getbbox(geometry)">
      <src>CREATE OR REPLACE FUNCTION getbbox(geometry) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'LWGEOM_to_BOX2DFLOAT4'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="getsrid(geometry)">
      <src>CREATE OR REPLACE FUNCTION getsrid(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_getSRID'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gettransactionid()">
      <src>CREATE OR REPLACE FUNCTION gettransactionid() 
  RETURNS xid AS 
$$'$libdir/postgis-1.5', 'getTransactionID'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="gidx_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION gidx_in(cstring) 
  RETURNS gidx AS 
$$'$libdir/postgis-1.5', 'gidx_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gidx_out(gidx)">
      <src>CREATE OR REPLACE FUNCTION gidx_out(gidx) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'gidx_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="hasbbox(geometry)">
      <src>CREATE OR REPLACE FUNCTION hasbbox(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_hasBBOX'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="height(chip)">
      <src>CREATE OR REPLACE FUNCTION height(chip) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'CHIP_getHeight'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="interiorringn(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION interiorringn(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_interiorringn_polygon'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="intersection(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION intersection(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'intersection'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="intersects(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION intersects(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'intersects'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="isclosed(geometry)">
      <src>CREATE OR REPLACE FUNCTION isclosed(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_isclosed_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="isempty(geometry)">
      <src>CREATE OR REPLACE FUNCTION isempty(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_isempty'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="isring(geometry)">
      <src>CREATE OR REPLACE FUNCTION isring(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'isring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="issimple(geometry)">
      <src>CREATE OR REPLACE FUNCTION issimple(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'issimple'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="isvalid(geometry)">
      <src>CREATE OR REPLACE FUNCTION isvalid(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'isvalid'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="length(geometry)">
      <src>CREATE OR REPLACE FUNCTION length(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_length_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="length2d(geometry)">
      <src>CREATE OR REPLACE FUNCTION length2d(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_length2d_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="length2d_spheroid(geometry, spheroid)">
      <src>CREATE OR REPLACE FUNCTION length2d_spheroid(geometry, spheroid) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_length2d_ellipsoid'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="length3d(geometry)">
      <src>CREATE OR REPLACE FUNCTION length3d(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_length_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="length3d_spheroid(geometry, spheroid)">
      <src>CREATE OR REPLACE FUNCTION length3d_spheroid(geometry, spheroid) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_length_ellipsoid_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="length_spheroid(geometry, spheroid)">
      <src>CREATE OR REPLACE FUNCTION length_spheroid(geometry, spheroid) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_length_ellipsoid_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="line_interpolate_point(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION line_interpolate_point(geometry, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_line_interpolate_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="line_locate_point(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION line_locate_point(geometry, geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_line_locate_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="line_substring(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION line_substring(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_line_substring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="linefrommultipoint(geometry)">
      <src>CREATE OR REPLACE FUNCTION linefrommultipoint(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_line_from_mpoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="linefromtext(text)">
      <src>CREATE OR REPLACE FUNCTION linefromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'LINESTRING'
	THEN GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="linefromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION linefromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'LINESTRING'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="linefromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION linefromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'LINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="linefromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION linefromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="linemerge(geometry)">
      <src>CREATE OR REPLACE FUNCTION linemerge(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'linemerge'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="linestringfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION linestringfromtext(text) 
  RETURNS geometry AS 
$$SELECT LineFromText($1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="linestringfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION linestringfromtext(text, integer) 
  RETURNS geometry AS 
$$SELECT LineFromText($1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="linestringfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION linestringfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'LINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="linestringfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION linestringfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="locate_along_measure(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION locate_along_measure(geometry, double precision) 
  RETURNS geometry AS 
$$ SELECT locate_between_measures($1, $2, $2) $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="locate_between_measures(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION locate_between_measures(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_locate_between_m'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="lockrow(text, text, text)">
      <src>CREATE OR REPLACE FUNCTION lockrow(text, text, text) 
  RETURNS integer AS 
$$ SELECT LockRow(current_schema(), $1, $2, $3, now()::timestamp+'1:00'); $$
  LANGUAGE sql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="lockrow(text, text, text, text)">
      <src>CREATE OR REPLACE FUNCTION lockrow(text, text, text, text) 
  RETURNS integer AS 
$$ SELECT LockRow($1, $2, $3, $4, now()::timestamp+'1:00'); $$
  LANGUAGE sql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="lockrow(text, text, text, text, timestamp without time zone)">
      <src>CREATE OR REPLACE FUNCTION lockrow(text, text, text, text, timestamp without time zone) 
  RETURNS integer AS 
$$ 
DECLARE
	myschema alias for $1;
	mytable alias for $2;
	myrid   alias for $3;
	authid alias for $4;
	expires alias for $5;
	ret int;
	mytoid oid;
	myrec RECORD;
	
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table WHERE expires &lt; now()'; 

	SELECT c.oid INTO mytoid FROM pg_class c, pg_namespace n
		WHERE c.relname = mytable
		AND c.relnamespace = n.oid
		AND n.nspname = myschema;

	-- RAISE NOTICE 'toid: %', mytoid;

	FOR myrec IN SELECT * FROM authorization_table WHERE 
		toid = mytoid AND rid = myrid
	LOOP
		IF myrec.authid != authid THEN
			RETURN 0;
		ELSE
			RETURN 1;
		END IF;
	END LOOP;

	EXECUTE 'INSERT INTO authorization_table VALUES ('||
		quote_literal(mytoid::text)||','||quote_literal(myrid)||
		','||quote_literal(expires::text)||
		','||quote_literal(authid) ||')';

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;
$$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="lockrow(text, text, text, timestamp without time zone)">
      <src>CREATE OR REPLACE FUNCTION lockrow(text, text, text, timestamp without time zone) 
  RETURNS integer AS 
$$ SELECT LockRow(current_schema(), $1, $2, $3, $4); $$
  LANGUAGE sql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="longtransactionsenabled()">
      <src>CREATE OR REPLACE FUNCTION longtransactionsenabled() 
  RETURNS boolean AS 
$$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="lwgeom_gist_compress(internal)">
      <src>CREATE OR REPLACE FUNCTION lwgeom_gist_compress(internal) 
  RETURNS internal AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_compress'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="lwgeom_gist_consistent(internal, geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION lwgeom_gist_consistent(internal, geometry, integer) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_consistent'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="lwgeom_gist_decompress(internal)">
      <src>CREATE OR REPLACE FUNCTION lwgeom_gist_decompress(internal) 
  RETURNS internal AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_decompress'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="lwgeom_gist_penalty(internal, internal, internal)">
      <src>CREATE OR REPLACE FUNCTION lwgeom_gist_penalty(internal, internal, internal) 
  RETURNS internal AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_penalty'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="lwgeom_gist_picksplit(internal, internal)">
      <src>CREATE OR REPLACE FUNCTION lwgeom_gist_picksplit(internal, internal) 
  RETURNS internal AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_picksplit'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="lwgeom_gist_same(box2d, box2d, internal)">
      <src>CREATE OR REPLACE FUNCTION lwgeom_gist_same(box2d, box2d, internal) 
  RETURNS internal AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_same'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="lwgeom_gist_union(bytea, internal)">
      <src>CREATE OR REPLACE FUNCTION lwgeom_gist_union(bytea, internal) 
  RETURNS internal AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_union'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="m(geometry)">
      <src>CREATE OR REPLACE FUNCTION m(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_m_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="makebox2d(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION makebox2d(geometry, geometry) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_construct'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="makebox3d(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION makebox3d(geometry, geometry) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'BOX3D_construct'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="makeline(geometry)">
      <src>CREATE OR REPLACE FUNCTION makeline(geometry) 
  RETURNS geometry AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="makeline(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION makeline(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makeline'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="makeline_garray(geometry[])">
      <src>CREATE OR REPLACE FUNCTION makeline_garray(geometry[]) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makeline_garray'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="makepoint(double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION makepoint(double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="makepoint(double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION makepoint(double precision, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="makepoint(double precision, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION makepoint(double precision, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="makepointm(double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION makepointm(double precision, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoint3dm'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="makepolygon(geometry)">
      <src>CREATE OR REPLACE FUNCTION makepolygon(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="makepolygon(geometry, geometry[])">
      <src>CREATE OR REPLACE FUNCTION makepolygon(geometry, geometry[]) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="max_distance(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION max_distance(geometry, geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_maxdistance2d_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="mem_size(geometry)">
      <src>CREATE OR REPLACE FUNCTION mem_size(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_mem_size'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="memcollect(geometry)">
      <src>CREATE OR REPLACE FUNCTION memcollect(geometry) 
  RETURNS geometry AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="memgeomunion(geometry)">
      <src>CREATE OR REPLACE FUNCTION memgeomunion(geometry) 
  RETURNS geometry AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="mlinefromtext(text)">
      <src>CREATE OR REPLACE FUNCTION mlinefromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'MULTILINESTRING'
	THEN GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="mlinefromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION mlinefromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE
	WHEN geometrytype(GeomFromText($1, $2)) = 'MULTILINESTRING'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="mlinefromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION mlinefromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="mlinefromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION mlinefromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTILINESTRING'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="mpointfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION mpointfromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'MULTIPOINT'
	THEN GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="mpointfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION mpointfromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1,$2)) = 'MULTIPOINT'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="mpointfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION mpointfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTIPOINT'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="mpointfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION mpointfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1,$2)) = 'MULTIPOINT'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="mpolyfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION mpolyfromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'MULTIPOLYGON'
	THEN GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="mpolyfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION mpolyfromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'MULTIPOLYGON'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="mpolyfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION mpolyfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="mpolyfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION mpolyfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="multi(geometry)">
      <src>CREATE OR REPLACE FUNCTION multi(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_multi'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="multilinefromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION multilinefromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="multilinefromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION multilinefromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTILINESTRING'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="multilinestringfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION multilinestringfromtext(text) 
  RETURNS geometry AS 
$$SELECT ST_MLineFromText($1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="multilinestringfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION multilinestringfromtext(text, integer) 
  RETURNS geometry AS 
$$SELECT MLineFromText($1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="multipointfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION multipointfromtext(text) 
  RETURNS geometry AS 
$$SELECT MPointFromText($1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="multipointfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION multipointfromtext(text, integer) 
  RETURNS geometry AS 
$$SELECT MPointFromText($1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="multipointfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION multipointfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTIPOINT'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="multipointfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION multipointfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1,$2)) = 'MULTIPOINT'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="multipolyfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION multipolyfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="multipolyfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION multipolyfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="multipolygonfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION multipolygonfromtext(text) 
  RETURNS geometry AS 
$$SELECT MPolyFromText($1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="multipolygonfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION multipolygonfromtext(text, integer) 
  RETURNS geometry AS 
$$SELECT MPolyFromText($1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="ndims(geometry)">
      <src>CREATE OR REPLACE FUNCTION ndims(geometry) 
  RETURNS smallint AS 
$$'$libdir/postgis-1.5', 'LWGEOM_ndims'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="noop(geometry)">
      <src>CREATE OR REPLACE FUNCTION noop(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_noop'$$
  LANGUAGE c VOLATILE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="npoints(geometry)">
      <src>CREATE OR REPLACE FUNCTION npoints(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_npoints'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="nrings(geometry)">
      <src>CREATE OR REPLACE FUNCTION nrings(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_nrings'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="numgeometries(geometry)">
      <src>CREATE OR REPLACE FUNCTION numgeometries(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_numgeometries_collection'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="numinteriorring(geometry)">
      <src>CREATE OR REPLACE FUNCTION numinteriorring(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_numinteriorrings_polygon'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="numinteriorrings(geometry)">
      <src>CREATE OR REPLACE FUNCTION numinteriorrings(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_numinteriorrings_polygon'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="numpoints(geometry)">
      <src>CREATE OR REPLACE FUNCTION numpoints(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_numpoints_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="overlaps(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION overlaps(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'overlaps'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="perimeter(geometry)">
      <src>CREATE OR REPLACE FUNCTION perimeter(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_perimeter_poly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="perimeter2d(geometry)">
      <src>CREATE OR REPLACE FUNCTION perimeter2d(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_perimeter2d_poly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="perimeter3d(geometry)">
      <src>CREATE OR REPLACE FUNCTION perimeter3d(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_perimeter_poly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="point_inside_circle(geometry, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION point_inside_circle(geometry, double precision, double precision, double precision) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_inside_circle_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="pointfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION pointfromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'POINT'
	THEN GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="pointfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION pointfromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'POINT'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="pointfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION pointfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'POINT'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="pointfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION pointfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'POINT'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="pointn(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION pointn(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_pointn_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="pointonsurface(geometry)">
      <src>CREATE OR REPLACE FUNCTION pointonsurface(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'pointonsurface'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="polyfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION polyfromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'POLYGON'
	THEN GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="polyfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION polyfromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'POLYGON'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="polyfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION polyfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'POLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="polyfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION polyfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'POLYGON'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="polygonfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION polygonfromtext(text) 
  RETURNS geometry AS 
$$SELECT PolyFromText($1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="polygonfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION polygonfromtext(text, integer) 
  RETURNS geometry AS 
$$SELECT PolyFromText($1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="polygonfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION polygonfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'POLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="polygonfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION polygonfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1,$2)) = 'POLYGON'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="polygonize(geometry)">
      <src>CREATE OR REPLACE FUNCTION polygonize(geometry) 
  RETURNS geometry AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="polygonize_garray(geometry[])">
      <src>CREATE OR REPLACE FUNCTION polygonize_garray(geometry[]) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'polygonize_garray'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="populate_geometry_columns()">
      <src>CREATE OR REPLACE FUNCTION populate_geometry_columns() 
  RETURNS text AS 
$$
DECLARE
	inserted    integer;
	oldcount    integer;
	probed      integer;
	stale       integer;
	gcs         RECORD;
	gc          RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;

BEGIN
	SELECT count(*) INTO oldcount FROM geometry_columns;
	inserted := 0;

	EXECUTE 'TRUNCATE geometry_columns';

	-- Count the number of geometry columns in all tables and views
	SELECT count(DISTINCT c.oid) INTO probed
	FROM pg_class c,
		 pg_attribute a,
		 pg_type t,
		 pg_namespace n
	WHERE (c.relkind = 'r' OR c.relkind = 'v')
	AND t.typname = 'geometry'
	AND a.attisdropped = false
	AND a.atttypid = t.oid
	AND a.attrelid = c.oid
	AND c.relnamespace = n.oid
	AND n.nspname NOT ILIKE 'pg_temp%';

	-- Iterate through all non-dropped geometry columns
	RAISE DEBUG 'Processing Tables.....';

	FOR gcs IN
	SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'r'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
	LOOP

	inserted := inserted + populate_geometry_columns(gcs.oid);
	END LOOP;

	-- Add views to geometry columns table
	RAISE DEBUG 'Processing Views.....';
	FOR gcs IN
	SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'v'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
	LOOP

	inserted := inserted + populate_geometry_columns(gcs.oid);
	END LOOP;

	IF oldcount &gt; inserted THEN
	stale = oldcount-inserted;
	ELSE
	stale = 0;
	END IF;

	RETURN 'probed:' ||probed|| ' inserted:'||inserted|| ' conflicts:'||probed-inserted|| ' deleted:'||stale;
END

$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="populate_geometry_columns(tbl_oid oid)">
      <src>CREATE OR REPLACE FUNCTION populate_geometry_columns(tbl_oid oid) 
  RETURNS integer AS 
$$
DECLARE
	gcs         RECORD;
	gc          RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;
	inserted    integer;

BEGIN
	inserted := 0;

	-- Iterate through all geometry columns in this table
	FOR gcs IN
	SELECT n.nspname, c.relname, a.attname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'r'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
		AND c.oid = tbl_oid
	LOOP

	RAISE DEBUG 'Processing table %.%.%', gcs.nspname, gcs.relname, gcs.attname;

	DELETE FROM geometry_columns
	  WHERE f_table_schema = gcs.nspname
	  AND f_table_name = gcs.relname
	  AND f_geometry_column = gcs.attname;

	gc_is_valid := true;

	-- Try to find srid check from system tables (pg_constraint)
	gsrid :=
		(SELECT replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', '')
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = gcs.nspname
		 AND c.relname = gcs.relname
		 AND a.attname = gcs.attname
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%srid(% = %');
	IF (gsrid IS NULL) THEN
		-- Try to find srid from the geometry itself
		EXECUTE 'SELECT srid(' || quote_ident(gcs.attname) || ')
				 FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gsrid := gc.srid;

		-- Try to apply srid check to column
		IF (gsrid IS NOT NULL) THEN
			BEGIN
				EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
						 ADD CONSTRAINT ' || quote_ident('enforce_srid_' || gcs.attname) || '
						 CHECK (srid(' || quote_ident(gcs.attname) || ') = ' || gsrid || ')';
			EXCEPTION
				WHEN check_violation THEN
					RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (srid(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gsrid;
					gc_is_valid := false;
			END;
		END IF;
	END IF;

	-- Try to find ndims check from system tables (pg_constraint)
	gndims :=
		(SELECT replace(split_part(s.consrc, ' = ', 2), ')', '')
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = gcs.nspname
		 AND c.relname = gcs.relname
		 AND a.attname = gcs.attname
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%ndims(% = %');
	IF (gndims IS NULL) THEN
		-- Try to find ndims from the geometry itself
		EXECUTE 'SELECT ndims(' || quote_ident(gcs.attname) || ')
				 FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gndims := gc.ndims;

		-- Try to apply ndims check to column
		IF (gndims IS NOT NULL) THEN
			BEGIN
				EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
						 ADD CONSTRAINT ' || quote_ident('enforce_dims_' || gcs.attname) || '
						 CHECK (ndims(' || quote_ident(gcs.attname) || ') = '||gndims||')';
			EXCEPTION
				WHEN check_violation THEN
					RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (ndims(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gndims;
					gc_is_valid := false;
			END;
		END IF;
	END IF;

	-- Try to find geotype check from system tables (pg_constraint)
	gtype :=
		(SELECT replace(split_part(s.consrc, '''', 2), ')', '')
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = gcs.nspname
		 AND c.relname = gcs.relname
		 AND a.attname = gcs.attname
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%geometrytype(% = %');
	IF (gtype IS NULL) THEN
		-- Try to find geotype from the geometry itself
		EXECUTE 'SELECT geometrytype(' || quote_ident(gcs.attname) || ')
				 FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gtype := gc.geometrytype;
		--IF (gtype IS NULL) THEN
		--    gtype := 'GEOMETRY';
		--END IF;

		-- Try to apply geometrytype check to column
		IF (gtype IS NOT NULL) THEN
			BEGIN
				EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				ADD CONSTRAINT ' || quote_ident('enforce_geotype_' || gcs.attname) || '
				CHECK ((geometrytype(' || quote_ident(gcs.attname) || ') = ' || quote_literal(gtype) || ') OR (' || quote_ident(gcs.attname) || ' IS NULL))';
			EXCEPTION
				WHEN check_violation THEN
					-- No geometry check can be applied. This column contains a number of geometry types.
					RAISE WARNING 'Could not add geometry type check (%) to table column: %.%.%', gtype, quote_ident(gcs.nspname),quote_ident(gcs.relname),quote_ident(gcs.attname);
			END;
		END IF;
	END IF;

	IF (gsrid IS NULL) THEN
		RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine the srid', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
	ELSIF (gndims IS NULL) THEN
		RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine the number of dimensions', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
	ELSIF (gtype IS NULL) THEN
		RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine the geometry type', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
	ELSE
		-- Only insert into geometry_columns if table constraints could be applied.
		IF (gc_is_valid) THEN
			INSERT INTO geometry_columns (f_table_catalog,f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, type)
			VALUES ('', gcs.nspname, gcs.relname, gcs.attname, gndims, gsrid, gtype);
			inserted := inserted + 1;
		END IF;
	END IF;
	END LOOP;

	-- Add views to geometry columns table
	FOR gcs IN
	SELECT n.nspname, c.relname, a.attname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'v'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
		AND c.oid = tbl_oid
	LOOP
		RAISE DEBUG 'Processing view %.%.%', gcs.nspname, gcs.relname, gcs.attname;

	DELETE FROM geometry_columns
	  WHERE f_table_schema = gcs.nspname
	  AND f_table_name = gcs.relname
	  AND f_geometry_column = gcs.attname;
	  
		EXECUTE 'SELECT ndims(' || quote_ident(gcs.attname) || ')
				 FROM ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gndims := gc.ndims;

		EXECUTE 'SELECT srid(' || quote_ident(gcs.attname) || ')
				 FROM ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gsrid := gc.srid;

		EXECUTE 'SELECT geometrytype(' || quote_ident(gcs.attname) || ')
				 FROM ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gtype := gc.geometrytype;

		IF (gndims IS NULL) THEN
			RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine ndims', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
		ELSIF (gsrid IS NULL) THEN
			RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine srid', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
		ELSIF (gtype IS NULL) THEN
			RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine gtype', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
		ELSE
			query := 'INSERT INTO geometry_columns (f_table_catalog,f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, type) ' ||
					 'VALUES ('''', ' || quote_literal(gcs.nspname) || ',' || quote_literal(gcs.relname) || ',' || quote_literal(gcs.attname) || ',' || gndims || ',' || gsrid || ',' || quote_literal(gtype) || ')';
			EXECUTE query;
			inserted := inserted + 1;
		END IF;
	END LOOP;

	RETURN inserted;
END

$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="postgis_addbbox(geometry)">
      <src>CREATE OR REPLACE FUNCTION postgis_addbbox(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_addBBOX'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_cache_bbox()">
      <src>CREATE OR REPLACE FUNCTION postgis_cache_bbox() 
  RETURNS trigger AS 
$$'$libdir/postgis-1.5', 'cache_bbox'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_dropbbox(geometry)">
      <src>CREATE OR REPLACE FUNCTION postgis_dropbbox(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_dropBBOX'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_full_version()">
      <src>CREATE OR REPLACE FUNCTION postgis_full_version() 
  RETURNS text AS 
$$
DECLARE
	libver text;
	projver text;
	geosver text;
	libxmlver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS="' || libver || '"';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS="' || geosver || '"';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ="' || projver || '"';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML="' || libxmlver || '"';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC="' || dbproc || '"';
	-- fullver = fullver || ' RELPROC="' || relproc || '"';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$
  LANGUAGE plpgsql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="postgis_geos_version()">
      <src>CREATE OR REPLACE FUNCTION postgis_geos_version() 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'postgis_geos_version'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_getbbox(geometry)">
      <src>CREATE OR REPLACE FUNCTION postgis_getbbox(geometry) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'LWGEOM_to_BOX2DFLOAT4'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_gist_joinsel(internal, oid, internal, smallint)">
      <src>CREATE OR REPLACE FUNCTION postgis_gist_joinsel(internal, oid, internal, smallint) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_joinsel'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_gist_sel(internal, oid, internal, integer)">
      <src>CREATE OR REPLACE FUNCTION postgis_gist_sel(internal, oid, internal, integer) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_sel'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_hasbbox(geometry)">
      <src>CREATE OR REPLACE FUNCTION postgis_hasbbox(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_hasBBOX'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_lib_build_date()">
      <src>CREATE OR REPLACE FUNCTION postgis_lib_build_date() 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'postgis_lib_build_date'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_lib_version()">
      <src>CREATE OR REPLACE FUNCTION postgis_lib_version() 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'postgis_lib_version'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_libxml_version()">
      <src>CREATE OR REPLACE FUNCTION postgis_libxml_version() 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'postgis_libxml_version'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_noop(geometry)">
      <src>CREATE OR REPLACE FUNCTION postgis_noop(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_noop'$$
  LANGUAGE c VOLATILE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_proj_version()">
      <src>CREATE OR REPLACE FUNCTION postgis_proj_version() 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'postgis_proj_version'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_scripts_build_date()">
      <src>CREATE OR REPLACE FUNCTION postgis_scripts_build_date() 
  RETURNS text AS 
$$SELECT '2012-10-07 12:25:36'::text AS version$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="postgis_scripts_installed()">
      <src>CREATE OR REPLACE FUNCTION postgis_scripts_installed() 
  RETURNS text AS 
$$SELECT '1.5 r7360'::text AS version$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="postgis_scripts_released()">
      <src>CREATE OR REPLACE FUNCTION postgis_scripts_released() 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'postgis_scripts_released'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_transform_geometry(geometry, text, text, integer)">
      <src>CREATE OR REPLACE FUNCTION postgis_transform_geometry(geometry, text, text, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'transform_geom'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_uses_stats()">
      <src>CREATE OR REPLACE FUNCTION postgis_uses_stats() 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'postgis_uses_stats'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="postgis_version()">
      <src>CREATE OR REPLACE FUNCTION postgis_version() 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'postgis_version'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="probe_geometry_columns()">
      <src>CREATE OR REPLACE FUNCTION probe_geometry_columns() 
  RETURNS text AS 
$$
DECLARE
	inserted integer;
	oldcount integer;
	probed integer;
	stale integer;
BEGIN

	SELECT count(*) INTO oldcount FROM geometry_columns;

	SELECT count(*) INTO probed
		FROM pg_class c, pg_attribute a, pg_type t,
			pg_namespace n,
			pg_constraint sridcheck, pg_constraint typecheck

		WHERE t.typname = 'geometry'
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND sridcheck.connamespace = n.oid
		AND typecheck.connamespace = n.oid
		AND sridcheck.conrelid = c.oid
		AND sridcheck.consrc LIKE '(srid('||a.attname||') = %)'
		AND typecheck.conrelid = c.oid
		AND typecheck.consrc LIKE
		'((geometrytype('||a.attname||') = ''%''::text) OR (% IS NULL))'
		;

	INSERT INTO geometry_columns SELECT
		''::varchar as f_table_catalogue,
		n.nspname::varchar as f_table_schema,
		c.relname::varchar as f_table_name,
		a.attname::varchar as f_geometry_column,
		2 as coord_dimension,
		trim(both  ' =)' from
			replace(replace(split_part(
				sridcheck.consrc, ' = ', 2), ')', ''), '(', ''))::integer AS srid,
		trim(both ' =)''' from substr(typecheck.consrc,
			strpos(typecheck.consrc, '='),
			strpos(typecheck.consrc, '::')-
			strpos(typecheck.consrc, '=')
			))::varchar as type
		FROM pg_class c, pg_attribute a, pg_type t,
			pg_namespace n,
			pg_constraint sridcheck, pg_constraint typecheck
		WHERE t.typname = 'geometry'
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND sridcheck.connamespace = n.oid
		AND typecheck.connamespace = n.oid
		AND sridcheck.conrelid = c.oid
		AND sridcheck.consrc LIKE '(st_srid('||a.attname||') = %)'
		AND typecheck.conrelid = c.oid
		AND typecheck.consrc LIKE
		'((geometrytype('||a.attname||') = ''%''::text) OR (% IS NULL))'

			AND NOT EXISTS (
					SELECT oid FROM geometry_columns gc
					WHERE c.relname::varchar = gc.f_table_name
					AND n.nspname::varchar = gc.f_table_schema
					AND a.attname::varchar = gc.f_geometry_column
			);

	GET DIAGNOSTICS inserted = ROW_COUNT;

	IF oldcount &gt; probed THEN
		stale = oldcount-probed;
	ELSE
		stale = 0;
	END IF;

	RETURN 'probed:'||probed::text||
		' inserted:'||inserted::text||
		' conflicts:'||(probed-inserted)::text||
		' stale:'||stale::text;
END

$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="relate(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION relate(geometry, geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'relate_full'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="relate(geometry, geometry, text)">
      <src>CREATE OR REPLACE FUNCTION relate(geometry, geometry, text) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'relate_pattern'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="removepoint(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION removepoint(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_removepoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="rename_geometry_table_constraints()">
      <src>CREATE OR REPLACE FUNCTION rename_geometry_table_constraints() 
  RETURNS text AS 
$$
SELECT 'rename_geometry_table_constraint() is obsoleted'::text
$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="reverse(geometry)">
      <src>CREATE OR REPLACE FUNCTION reverse(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_reverse'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="rotate(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION rotate(geometry, double precision) 
  RETURNS geometry AS 
$$SELECT rotateZ($1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="rotatex(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION rotatex(geometry, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1, 1, 0, 0, 0, cos($2), -sin($2), 0, sin($2), cos($2), 0, 0, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="rotatey(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION rotatey(geometry, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1,  cos($2), 0, sin($2),  0, 1, 0,  -sin($2), 0, cos($2), 0,  0, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="rotatez(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION rotatez(geometry, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1,  cos($2), -sin($2), 0,  sin($2), cos($2), 0,  0, 0, 1,  0, 0, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="scale(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION scale(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT scale($1, $2, $3, 1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="scale(geometry, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION scale(geometry, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1,  $2, 0, 0,  0, $3, 0,  0, 0, $4,  0, 0, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="se_envelopesintersect(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION se_envelopesintersect(geometry, geometry) 
  RETURNS boolean AS 
$$ 
	SELECT $1 &amp;&amp; $2
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="se_is3d(geometry)">
      <src>CREATE OR REPLACE FUNCTION se_is3d(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_hasz'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="se_ismeasured(geometry)">
      <src>CREATE OR REPLACE FUNCTION se_ismeasured(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_hasm'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="se_locatealong(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION se_locatealong(geometry, double precision) 
  RETURNS geometry AS 
$$ SELECT locate_between_measures($1, $2, $2) $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="se_locatebetween(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION se_locatebetween(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_locate_between_m'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="se_m(geometry)">
      <src>CREATE OR REPLACE FUNCTION se_m(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_m_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="se_z(geometry)">
      <src>CREATE OR REPLACE FUNCTION se_z(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_z_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="segmentize(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION segmentize(geometry, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_segmentize2d'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="setfactor(chip, real)">
      <src>CREATE OR REPLACE FUNCTION setfactor(chip, real) 
  RETURNS chip AS 
$$'$libdir/postgis-1.5', 'CHIP_setFactor'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="setpoint(geometry, integer, geometry)">
      <src>CREATE OR REPLACE FUNCTION setpoint(geometry, integer, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_setpoint_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="setsrid(chip, integer)">
      <src>CREATE OR REPLACE FUNCTION setsrid(chip, integer) 
  RETURNS chip AS 
$$'$libdir/postgis-1.5', 'CHIP_setSRID'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="setsrid(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION setsrid(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_setSRID'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="shift_longitude(geometry)">
      <src>CREATE OR REPLACE FUNCTION shift_longitude(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_longitude_shift'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="simplify(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION simplify(geometry, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_simplify2d'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="snaptogrid(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION snaptogrid(geometry, double precision) 
  RETURNS geometry AS 
$$SELECT SnapToGrid($1, 0, 0, $2, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="snaptogrid(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION snaptogrid(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT SnapToGrid($1, 0, 0, $2, $3)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="snaptogrid(geometry, double precision, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION snaptogrid(geometry, double precision, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_snaptogrid'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_snaptogrid_pointoff'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="spheroid_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION spheroid_in(cstring) 
  RETURNS spheroid AS 
$$'$libdir/postgis-1.5', 'ellipsoid_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="spheroid_out(spheroid)">
      <src>CREATE OR REPLACE FUNCTION spheroid_out(spheroid) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'ellipsoid_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="srid(chip)">
      <src>CREATE OR REPLACE FUNCTION srid(chip) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'CHIP_getSRID'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="srid(geometry)">
      <src>CREATE OR REPLACE FUNCTION srid(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_getSRID'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_accum(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_accum(geometry) 
  RETURNS geometry[] AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_addmeasure(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_addmeasure(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'ST_AddMeasure'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_addpoint(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_addpoint(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_addpoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_addpoint(geometry, geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_addpoint(geometry, geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_addpoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1,  $2, $3, 0,  $4, $5, 0,  0, 0, 1,  $6, $7, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_affine'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_area(geography)">
      <src>CREATE OR REPLACE FUNCTION st_area(geography) 
  RETURNS double precision AS 
$$SELECT ST_Area($1, true)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_area(geography, boolean)">
      <src>CREATE OR REPLACE FUNCTION st_area(geography, boolean) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'geography_area'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_area(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_area(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_area_polygon'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_area(text)">
      <src>CREATE OR REPLACE FUNCTION st_area(text) 
  RETURNS double precision AS 
$$ SELECT ST_Area($1::geometry);  $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_area2d(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_area2d(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_area_polygon'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_asbinary(geography)">
      <src>CREATE OR REPLACE FUNCTION st_asbinary(geography) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'geography_as_binary'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_asbinary(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_asbinary(geometry) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asBinary'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_asbinary(geometry, text)">
      <src>CREATE OR REPLACE FUNCTION st_asbinary(geometry, text) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asBinary'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_asbinary(text)">
      <src>CREATE OR REPLACE FUNCTION st_asbinary(text) 
  RETURNS bytea AS 
$$ SELECT ST_AsBinary($1::geometry);  $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asewkb(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_asewkb(geometry) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'WKBFromLWGEOM'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_asewkb(geometry, text)">
      <src>CREATE OR REPLACE FUNCTION st_asewkb(geometry, text) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'WKBFromLWGEOM'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_asewkt(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_asewkt(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asEWKT'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_asgeojson(geography)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(geography) 
  RETURNS text AS 
$$SELECT _ST_AsGeoJson(1, $1, 15, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgeojson(geography, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(geography, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGeoJson(1, $1, $2, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgeojson(geography, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(geography, integer, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGeoJson(1, $1, $2, $3)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgeojson(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(geometry) 
  RETURNS text AS 
$$SELECT _ST_AsGeoJson(1, $1, 15, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgeojson(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(geometry, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGeoJson(1, $1, $2, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgeojson(geometry, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(geometry, integer, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGeoJson(1, $1, $2, $3)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgeojson(integer, geography)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(integer, geography) 
  RETURNS text AS 
$$SELECT _ST_AsGeoJson($1, $2, 15, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgeojson(integer, geography, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(integer, geography, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGeoJson($1, $2, $3, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgeojson(integer, geography, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(integer, geography, integer, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGeoJson($1, $2, $3, $4)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgeojson(integer, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(integer, geometry) 
  RETURNS text AS 
$$SELECT _ST_AsGeoJson($1, $2, 15, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgeojson(integer, geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(integer, geometry, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGeoJson($1, $2, $3, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgeojson(integer, geometry, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(integer, geometry, integer, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGeoJson($1, $2, $3, $4)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgeojson(text)">
      <src>CREATE OR REPLACE FUNCTION st_asgeojson(text) 
  RETURNS text AS 
$$ SELECT ST_AsGeoJson($1::geometry);  $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(geography)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(geography) 
  RETURNS text AS 
$$SELECT _ST_AsGML(2, $1, 15, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(geography, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(geography, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGML(2, $1, $2, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(geography, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(geography, integer, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGML(2, $1, $2, $3)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(geometry) 
  RETURNS text AS 
$$SELECT _ST_AsGML(2, $1, 15, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(geometry, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGML(2, $1, $2, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(geometry, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(geometry, integer, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGML(2, $1, $2, $3)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(integer, geography)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(integer, geography) 
  RETURNS text AS 
$$SELECT _ST_AsGML($1, $2, 15, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(integer, geography, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(integer, geography, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGML($1, $2, $3, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(integer, geography, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(integer, geography, integer, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGML($1, $2, $3, $4)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(integer, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(integer, geometry) 
  RETURNS text AS 
$$SELECT _ST_AsGML($1, $2, 15, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(integer, geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(integer, geometry, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGML($1, $2, $3, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(integer, geometry, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(integer, geometry, integer, integer) 
  RETURNS text AS 
$$SELECT _ST_AsGML($1, $2, $3, $4)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_asgml(text)">
      <src>CREATE OR REPLACE FUNCTION st_asgml(text) 
  RETURNS text AS 
$$ SELECT ST_AsGML($1::geometry);  $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_ashexewkb(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_ashexewkb(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asHEXEWKB'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_ashexewkb(geometry, text)">
      <src>CREATE OR REPLACE FUNCTION st_ashexewkb(geometry, text) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asHEXEWKB'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_askml(geography)">
      <src>CREATE OR REPLACE FUNCTION st_askml(geography) 
  RETURNS text AS 
$$SELECT _ST_AsKML(2, $1, 15)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_askml(geography, integer)">
      <src>CREATE OR REPLACE FUNCTION st_askml(geography, integer) 
  RETURNS text AS 
$$SELECT _ST_AsKML(2, $1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_askml(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_askml(geometry) 
  RETURNS text AS 
$$SELECT _ST_AsKML(2, ST_Transform($1,4326), 15)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_askml(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_askml(geometry, integer) 
  RETURNS text AS 
$$SELECT _ST_AsKML(2, ST_Transform($1,4326), $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_askml(integer, geography)">
      <src>CREATE OR REPLACE FUNCTION st_askml(integer, geography) 
  RETURNS text AS 
$$SELECT _ST_AsKML($1, $2, 15)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_askml(integer, geography, integer)">
      <src>CREATE OR REPLACE FUNCTION st_askml(integer, geography, integer) 
  RETURNS text AS 
$$SELECT _ST_AsKML($1, $2, $3)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_askml(integer, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_askml(integer, geometry) 
  RETURNS text AS 
$$SELECT _ST_AsKML($1, ST_Transform($2,4326), 15)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_askml(integer, geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_askml(integer, geometry, integer) 
  RETURNS text AS 
$$SELECT _ST_AsKML($1, ST_Transform($2,4326), $3)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_askml(text)">
      <src>CREATE OR REPLACE FUNCTION st_askml(text) 
  RETURNS text AS 
$$ SELECT ST_AsKML($1::geometry);  $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_assvg(geography)">
      <src>CREATE OR REPLACE FUNCTION st_assvg(geography) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'geography_as_svg'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_assvg(geography, integer)">
      <src>CREATE OR REPLACE FUNCTION st_assvg(geography, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'geography_as_svg'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_assvg(geography, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION st_assvg(geography, integer, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'geography_as_svg'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_assvg(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_assvg(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'assvg_geometry'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_assvg(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_assvg(geometry, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'assvg_geometry'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_assvg(geometry, integer, integer)">
      <src>CREATE OR REPLACE FUNCTION st_assvg(geometry, integer, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'assvg_geometry'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_assvg(text)">
      <src>CREATE OR REPLACE FUNCTION st_assvg(text) 
  RETURNS text AS 
$$ SELECT ST_AsSVG($1::geometry);  $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_astext(geography)">
      <src>CREATE OR REPLACE FUNCTION st_astext(geography) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'geography_as_text'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_astext(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_astext(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_asText'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_astext(text)">
      <src>CREATE OR REPLACE FUNCTION st_astext(text) 
  RETURNS text AS 
$$ SELECT ST_AsText($1::geometry);  $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_azimuth(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_azimuth(geometry, geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_azimuth'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_bdmpolyfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_bdmpolyfromtext(text, integer) 
  RETURNS geometry AS 
$$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(ST_BuildArea(mline));

	RETURN geom;
END;
$$
  LANGUAGE plpgsql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_bdpolyfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_bdpolyfromtext(text, integer) 
  RETURNS geometry AS 
$$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := ST_BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$$
  LANGUAGE plpgsql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_boundary(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_boundary(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'boundary'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_box(box3d)">
      <src>CREATE OR REPLACE FUNCTION st_box(box3d) 
  RETURNS box AS 
$$'$libdir/postgis-1.5', 'BOX3D_to_BOX'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_box(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_box(geometry) 
  RETURNS box AS 
$$'$libdir/postgis-1.5', 'LWGEOM_to_BOX'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_box2d(box3d)">
      <src>CREATE OR REPLACE FUNCTION st_box2d(box3d) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'BOX3D_to_BOX2DFLOAT4'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_box2d(box3d_extent)">
      <src>CREATE OR REPLACE FUNCTION st_box2d(box3d_extent) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'BOX3D_to_BOX2DFLOAT4'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_box2d(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_box2d(geometry) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'LWGEOM_to_BOX2DFLOAT4'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_box2d_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION st_box2d_in(cstring) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_box2d_out(box2d)">
      <src>CREATE OR REPLACE FUNCTION st_box2d_out(box2d) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_box3d(box2d)">
      <src>CREATE OR REPLACE FUNCTION st_box3d(box2d) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_to_BOX3D'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_box3d(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_box3d(geometry) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'LWGEOM_to_BOX3D'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_box3d_extent(box3d_extent)">
      <src>CREATE OR REPLACE FUNCTION st_box3d_extent(box3d_extent) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'BOX3D_extent_to_BOX3D'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_box3d_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION st_box3d_in(cstring) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'BOX3D_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_box3d_out(box3d)">
      <src>CREATE OR REPLACE FUNCTION st_box3d_out(box3d) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'BOX3D_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_buffer(geography, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_buffer(geography, double precision) 
  RETURNS geography AS 
$$SELECT geography(ST_Transform(ST_Buffer(ST_Transform(geometry($1), _ST_BestSRID($1)), $2), 4326))$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_buffer(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_buffer(geometry, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'buffer'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_buffer(geometry, double precision, integer)">
      <src>CREATE OR REPLACE FUNCTION st_buffer(geometry, double precision, integer) 
  RETURNS geometry AS 
$$ SELECT _ST_Buffer($1, $2,
		CAST('quad_segs='||CAST($3 AS text) as cstring))
	   $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_buffer(geometry, double precision, text)">
      <src>CREATE OR REPLACE FUNCTION st_buffer(geometry, double precision, text) 
  RETURNS geometry AS 
$$ SELECT _ST_Buffer($1, $2,
		CAST( regexp_replace($3, '^[0123456789]+$',
			'quad_segs='||$3) AS cstring)
		)
	   $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_buffer(text, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_buffer(text, double precision) 
  RETURNS geometry AS 
$$ SELECT ST_Buffer($1::geometry, $2);  $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_buildarea(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_buildarea(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_buildarea'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_bytea(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_bytea(geometry) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'LWGEOM_to_bytea'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_centroid(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_centroid(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'centroid'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_chip_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION st_chip_in(cstring) 
  RETURNS chip AS 
$$'$libdir/postgis-1.5', 'CHIP_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_chip_out(chip)">
      <src>CREATE OR REPLACE FUNCTION st_chip_out(chip) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'CHIP_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_closestpoint(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_closestpoint(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_closestpoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_collect(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_collect(geometry) 
  RETURNS geometry AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_collect(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_collect(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_collect'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_collect(geometry[])">
      <src>CREATE OR REPLACE FUNCTION st_collect(geometry[]) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_collect_garray'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_collectionextract(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_collectionextract(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'ST_CollectionExtract'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_combine_bbox(box2d, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_combine_bbox(box2d, geometry) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_combine'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_combine_bbox(box3d, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_combine_bbox(box3d, geometry) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'BOX3D_combine'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_combine_bbox(box3d_extent, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_combine_bbox(box3d_extent, geometry) 
  RETURNS box3d_extent AS 
$$'$libdir/postgis-1.5', 'BOX3D_combine'$$
  LANGUAGE c IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_compression(chip)">
      <src>CREATE OR REPLACE FUNCTION st_compression(chip) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'CHIP_getCompression'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_contains(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_contains(geometry, geometry) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_Contains($1,$2)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_containsproperly(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_containsproperly(geometry, geometry) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_ContainsProperly($1,$2)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_convexhull(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_convexhull(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'convexhull'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_coorddim(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_coorddim(geometry) 
  RETURNS smallint AS 
$$'$libdir/postgis-1.5', 'LWGEOM_ndims'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_coveredby(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION st_coveredby(geography, geography) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_Covers($2, $1)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_coveredby(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_coveredby(geometry, geometry) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_CoveredBy($1,$2)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_coveredby(text, text)">
      <src>CREATE OR REPLACE FUNCTION st_coveredby(text, text) 
  RETURNS boolean AS 
$$ SELECT ST_CoveredBy($1::geometry, $2::geometry);  $$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_covers(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION st_covers(geography, geography) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_Covers($1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_covers(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_covers(geometry, geometry) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_Covers($1,$2)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_covers(text, text)">
      <src>CREATE OR REPLACE FUNCTION st_covers(text, text) 
  RETURNS boolean AS 
$$ SELECT ST_Covers($1::geometry, $2::geometry);  $$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_crosses(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_crosses(geometry, geometry) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_Crosses($1,$2)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_curvetoline(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_curvetoline(geometry) 
  RETURNS geometry AS 
$$SELECT ST_CurveToLine($1, 32)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_curvetoline(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_curvetoline(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_curve_segmentize'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_datatype(chip)">
      <src>CREATE OR REPLACE FUNCTION st_datatype(chip) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'CHIP_getDatatype'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_dfullywithin(geometry, geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_dfullywithin(geometry, geometry, double precision) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; ST_Expand($2,$3) AND $2 &amp;&amp; ST_Expand($1,$3) AND _ST_DFullyWithin(ST_ConvexHull($1), ST_ConvexHull($2), $3)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_difference(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_difference(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'difference'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_dimension(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_dimension(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_dimension'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_disjoint(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_disjoint(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'disjoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_distance(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION st_distance(geography, geography) 
  RETURNS double precision AS 
$$SELECT _ST_Distance($1, $2, 0.0, true)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_distance(geography, geography, boolean)">
      <src>CREATE OR REPLACE FUNCTION st_distance(geography, geography, boolean) 
  RETURNS double precision AS 
$$SELECT _ST_Distance($1, $2, 0.0, $3)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_distance(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_distance(geometry, geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_mindistance2d'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_distance(text, text)">
      <src>CREATE OR REPLACE FUNCTION st_distance(text, text) 
  RETURNS double precision AS 
$$ SELECT ST_Distance($1::geometry, $2::geometry);  $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_distance_sphere(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_distance_sphere(geometry, geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_distance_sphere'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_distance_spheroid(geometry, geometry, spheroid)">
      <src>CREATE OR REPLACE FUNCTION st_distance_spheroid(geometry, geometry, spheroid) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_distance_ellipsoid'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_dump(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_dump(geometry) 
  RETURNS SETOF geometry_dump AS 
$$'$libdir/postgis-1.5', 'LWGEOM_dump'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1
  ROWS 1000;</src>
    </Proc>
    <Proc nm="st_dumppoints(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_dumppoints(geometry) 
  RETURNS SETOF geometry_dump AS 
$$
  SELECT * FROM _ST_DumpPoints($1, NULL);
$$
  LANGUAGE sql VOLATILE STRICT
  COST 100
  ROWS 1000;</src>
    </Proc>
    <Proc nm="st_dumprings(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_dumprings(geometry) 
  RETURNS SETOF geometry_dump AS 
$$'$libdir/postgis-1.5', 'LWGEOM_dump_rings'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1
  ROWS 1000;</src>
    </Proc>
    <Proc nm="st_dwithin(geography, geography, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_dwithin(geography, geography, double precision) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; _ST_Expand($2,$3) AND $2 &amp;&amp; _ST_Expand($1,$3) AND _ST_DWithin($1, $2, $3, true)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_dwithin(geography, geography, double precision, boolean)">
      <src>CREATE OR REPLACE FUNCTION st_dwithin(geography, geography, double precision, boolean) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; _ST_Expand($2,$3) AND $2 &amp;&amp; _ST_Expand($1,$3) AND _ST_DWithin($1, $2, $3, $4)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_dwithin(geometry, geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_dwithin(geometry, geometry, double precision) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; ST_Expand($2,$3) AND $2 &amp;&amp; ST_Expand($1,$3) AND _ST_DWithin($1, $2, $3)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_dwithin(text, text, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_dwithin(text, text, double precision) 
  RETURNS boolean AS 
$$ SELECT ST_DWithin($1::geometry, $2::geometry, $3);  $$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_endpoint(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_endpoint(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_endpoint_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_envelope(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_envelope(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_envelope'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_equals(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_equals(geometry, geometry) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_Equals($1,$2)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_estimated_extent(text, text)">
      <src>CREATE OR REPLACE FUNCTION st_estimated_extent(text, text) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'LWGEOM_estimated_extent'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_estimated_extent(text, text, text)">
      <src>CREATE OR REPLACE FUNCTION st_estimated_extent(text, text, text) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'LWGEOM_estimated_extent'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_expand(box2d, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_expand(box2d, double precision) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_expand'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_expand(box3d, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_expand(box3d, double precision) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'BOX3D_expand'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_expand(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_expand(geometry, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_expand'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_extent(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_extent(geometry) 
  RETURNS box3d_extent AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_extent3d(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_extent3d(geometry) 
  RETURNS box3d AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_exteriorring(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_exteriorring(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_exteriorring_polygon'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_factor(chip)">
      <src>CREATE OR REPLACE FUNCTION st_factor(chip) 
  RETURNS real AS 
$$'$libdir/postgis-1.5', 'CHIP_getFactor'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_find_extent(text, text)">
      <src>CREATE OR REPLACE FUNCTION st_find_extent(text, text) 
  RETURNS box2d AS 
$$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent("' || columnname || '") FROM "' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$$
  LANGUAGE plpgsql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_find_extent(text, text, text)">
      <src>CREATE OR REPLACE FUNCTION st_find_extent(text, text, text) 
  RETURNS box2d AS 
$$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent("' || columnname || '") FROM "' || schemaname || '"."' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$$
  LANGUAGE plpgsql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_force_2d(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_force_2d(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_2d'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_force_3d(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_force_3d(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_3dz'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_force_3dm(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_force_3dm(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_3dm'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_force_3dz(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_force_3dz(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_3dz'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_force_4d(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_force_4d(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_4d'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_force_collection(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_force_collection(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_collection'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_forcerhr(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_forcerhr(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_forceRHR_poly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geogfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_geogfromtext(text) 
  RETURNS geography AS 
$$'$libdir/postgis-1.5', 'geography_from_text'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geogfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_geogfromwkb(bytea) 
  RETURNS geography AS 
$$'$libdir/postgis-1.5', 'geography_from_binary'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geographyfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_geographyfromtext(text) 
  RETURNS geography AS 
$$'$libdir/postgis-1.5', 'geography_from_text'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geohash(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geohash(geometry) 
  RETURNS text AS 
$$SELECT ST_GeoHash($1, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_geohash(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_geohash(geometry, integer) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'ST_GeoHash'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geomcollfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_geomcollfromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromText($1)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_geomcollfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_geomcollfromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromText($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromText($1,$2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_geomcollfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_geomcollfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromWKB($1)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_geomcollfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION st_geomcollfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE
	WHEN geometrytype(GeomFromWKB($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_geometry(box2d)">
      <src>CREATE OR REPLACE FUNCTION st_geometry(box2d) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_to_LWGEOM'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry(box3d)">
      <src>CREATE OR REPLACE FUNCTION st_geometry(box3d) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'BOX3D_to_LWGEOM'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry(box3d_extent)">
      <src>CREATE OR REPLACE FUNCTION st_geometry(box3d_extent) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'BOX3D_to_LWGEOM'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_geometry(bytea) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_from_bytea'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry(chip)">
      <src>CREATE OR REPLACE FUNCTION st_geometry(chip) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'CHIP_to_LWGEOM'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry(text)">
      <src>CREATE OR REPLACE FUNCTION st_geometry(text) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'parse_WKT_lwgeom'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_above(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_above(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_above'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_analyze(internal)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_analyze(internal) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_analyze'$$
  LANGUAGE c VOLATILE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_below(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_below(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_below'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_cmp(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_cmp(geometry, geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'lwgeom_cmp'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_contain(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_contain(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_contain'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_contained(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_contained(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_contained'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_eq(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_eq(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'lwgeom_eq'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_ge(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_ge(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'lwgeom_ge'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_gt(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_gt(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'lwgeom_gt'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_in(cstring) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_le(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_le(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'lwgeom_le'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_left(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_left(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_left'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_lt(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_lt(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'lwgeom_lt'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_out(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_out(geometry) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'LWGEOM_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_overabove(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_overabove(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_overabove'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_overbelow(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_overbelow(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_overbelow'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_overlap(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_overlap(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_overlap'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_overleft(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_overleft(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_overleft'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_overright(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_overright(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_overright'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_recv(internal)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_recv(internal) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_recv'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_right(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_right(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_right'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_same(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_same(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_samebox'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometry_send(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometry_send(geometry) 
  RETURNS bytea AS 
$$'$libdir/postgis-1.5', 'LWGEOM_send'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometryfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_geometryfromtext(text) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_from_text'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometryfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_geometryfromtext(text, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_from_text'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometryn(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_geometryn(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_geometryn_collection'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geometrytype(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_geometrytype(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'geometry_geometrytype'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geomfromewkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_geomfromewkb(bytea) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOMFromWKB'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geomfromewkt(text)">
      <src>CREATE OR REPLACE FUNCTION st_geomfromewkt(text) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'parse_WKT_lwgeom'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geomfromgml(text)">
      <src>CREATE OR REPLACE FUNCTION st_geomfromgml(text) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'geom_from_gml'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geomfromkml(text)">
      <src>CREATE OR REPLACE FUNCTION st_geomfromkml(text) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'geom_from_kml'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geomfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_geomfromtext(text) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_from_text'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geomfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_geomfromtext(text, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_from_text'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geomfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_geomfromwkb(bytea) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_from_WKB'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_geomfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION st_geomfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$SELECT ST_SetSRID(ST_GeomFromWKB($1), $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_gmltosql(text)">
      <src>CREATE OR REPLACE FUNCTION st_gmltosql(text) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'geom_from_gml'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_hasarc(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_hasarc(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_has_arc'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_hausdorffdistance(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_hausdorffdistance(geometry, geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'hausdorffdistance'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_hausdorffdistance(geometry, geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_hausdorffdistance(geometry, geometry, double precision) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'hausdorffdistancedensify'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_height(chip)">
      <src>CREATE OR REPLACE FUNCTION st_height(chip) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'CHIP_getHeight'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_interiorringn(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_interiorringn(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_interiorringn_polygon'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_intersection(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION st_intersection(geography, geography) 
  RETURNS geography AS 
$$SELECT geography(ST_Transform(ST_Intersection(ST_Transform(geometry($1), _ST_BestSRID($1, $2)), ST_Transform(geometry($2), _ST_BestSRID($1, $2))), 4326))$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_intersection(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_intersection(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'intersection'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_intersection(text, text)">
      <src>CREATE OR REPLACE FUNCTION st_intersection(text, text) 
  RETURNS geometry AS 
$$ SELECT ST_Intersection($1::geometry, $2::geometry);  $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_intersects(geography, geography)">
      <src>CREATE OR REPLACE FUNCTION st_intersects(geography, geography) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_Distance($1, $2, 0.0, false) &lt; 0.00001$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_intersects(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_intersects(geometry, geometry) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_Intersects($1,$2)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_intersects(text, text)">
      <src>CREATE OR REPLACE FUNCTION st_intersects(text, text) 
  RETURNS boolean AS 
$$ SELECT ST_Intersects($1::geometry, $2::geometry);  $$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_isclosed(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_isclosed(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_isclosed_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_isempty(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_isempty(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_isempty'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_isring(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_isring(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'isring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_issimple(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_issimple(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'issimple'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_isvalid(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_isvalid(geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'isvalid'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_isvalidreason(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_isvalidreason(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'isvalidreason'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_length(geography)">
      <src>CREATE OR REPLACE FUNCTION st_length(geography) 
  RETURNS double precision AS 
$$SELECT ST_Length($1, true)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_length(geography, boolean)">
      <src>CREATE OR REPLACE FUNCTION st_length(geography, boolean) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'geography_length'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_length(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_length(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_length2d_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_length(text)">
      <src>CREATE OR REPLACE FUNCTION st_length(text) 
  RETURNS double precision AS 
$$ SELECT ST_Length($1::geometry);  $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_length2d(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_length2d(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_length2d_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_length2d_spheroid(geometry, spheroid)">
      <src>CREATE OR REPLACE FUNCTION st_length2d_spheroid(geometry, spheroid) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_length2d_ellipsoid'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_length3d(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_length3d(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_length_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_length3d_spheroid(geometry, spheroid)">
      <src>CREATE OR REPLACE FUNCTION st_length3d_spheroid(geometry, spheroid) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_length_ellipsoid_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_length_spheroid(geometry, spheroid)">
      <src>CREATE OR REPLACE FUNCTION st_length_spheroid(geometry, spheroid) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_length_ellipsoid_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_line_interpolate_point(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_line_interpolate_point(geometry, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_line_interpolate_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_line_locate_point(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_line_locate_point(geometry, geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_line_locate_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_line_substring(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_line_substring(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_line_substring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_linecrossingdirection(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_linecrossingdirection(geometry, geometry) 
  RETURNS integer AS 
$$ SELECT CASE WHEN NOT $1 &amp;&amp; $2 THEN 0 ELSE _ST_LineCrossingDirection($1,$2) END $$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_linefrommultipoint(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_linefrommultipoint(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_line_from_mpoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_linefromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_linefromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'LINESTRING'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_linefromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_linefromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'LINESTRING'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_linefromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_linefromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_linefromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION st_linefromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_linemerge(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_linemerge(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'linemerge'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_linestringfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_linestringfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'LINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_linestringfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION st_linestringfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_linetocurve(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_linetocurve(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_line_desegmentize'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_locate_along_measure(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_locate_along_measure(geometry, double precision) 
  RETURNS geometry AS 
$$ SELECT locate_between_measures($1, $2, $2) $$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_locate_between_measures(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_locate_between_measures(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_locate_between_m'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_locatebetweenelevations(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_locatebetweenelevations(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'ST_LocateBetweenElevations'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_longestline(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_longestline(geometry, geometry) 
  RETURNS geometry AS 
$$SELECT _ST_LongestLine(ST_ConvexHull($1), ST_ConvexHull($2))$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_m(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_m(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_m_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_makebox2d(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_makebox2d(geometry, geometry) 
  RETURNS box2d AS 
$$'$libdir/postgis-1.5', 'BOX2DFLOAT4_construct'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_makebox3d(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_makebox3d(geometry, geometry) 
  RETURNS box3d AS 
$$'$libdir/postgis-1.5', 'BOX3D_construct'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_makeenvelope(double precision, double precision, double precision, double precision, integer)">
      <src>CREATE OR REPLACE FUNCTION st_makeenvelope(double precision, double precision, double precision, double precision, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'ST_MakeEnvelope'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_makeline(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_makeline(geometry) 
  RETURNS geometry AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_makeline(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_makeline(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makeline'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_makeline(geometry[])">
      <src>CREATE OR REPLACE FUNCTION st_makeline(geometry[]) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makeline_garray'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_makeline_garray(geometry[])">
      <src>CREATE OR REPLACE FUNCTION st_makeline_garray(geometry[]) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makeline_garray'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_makepoint(double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_makepoint(double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_makepoint(double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_makepoint(double precision, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_makepoint(double precision, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_makepoint(double precision, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_makepointm(double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_makepointm(double precision, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoint3dm'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_makepolygon(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_makepolygon(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_makepolygon(geometry, geometry[])">
      <src>CREATE OR REPLACE FUNCTION st_makepolygon(geometry, geometry[]) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_maxdistance(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_maxdistance(geometry, geometry) 
  RETURNS double precision AS 
$$SELECT _ST_MaxDistance(ST_ConvexHull($1), ST_ConvexHull($2))$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mem_size(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_mem_size(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_mem_size'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_memcollect(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_memcollect(geometry) 
  RETURNS geometry AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_memunion(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_memunion(geometry) 
  RETURNS geometry AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_minimumboundingcircle(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_minimumboundingcircle(geometry) 
  RETURNS geometry AS 
$$SELECT ST_MinimumBoundingCircle($1, 48)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_minimumboundingcircle(inputgeom geometry, segs_per_quarter integer)">
      <src>CREATE OR REPLACE FUNCTION st_minimumboundingcircle(inputgeom geometry, segs_per_quarter integer) 
  RETURNS geometry AS 
$$
	DECLARE
	hull GEOMETRY;
	ring GEOMETRY;
	center GEOMETRY;
	radius DOUBLE PRECISION;
	dist DOUBLE PRECISION;
	d DOUBLE PRECISION;
	idx1 integer;
	idx2 integer;
	l1 GEOMETRY;
	l2 GEOMETRY;
	p1 GEOMETRY;
	p2 GEOMETRY;
	a1 DOUBLE PRECISION;
	a2 DOUBLE PRECISION;


	BEGIN

	-- First compute the ConvexHull of the geometry
	hull = ST_ConvexHull(inputgeom);
	--A point really has no MBC
	IF ST_GeometryType(hull) = 'ST_Point' THEN
		RETURN hull;
	END IF;
	-- convert the hull perimeter to a linestring so we can manipulate individual points
	--If its already a linestring force it to a closed linestring
	ring = CASE WHEN ST_GeometryType(hull) = 'ST_LineString' THEN ST_AddPoint(hull, ST_StartPoint(hull)) ELSE ST_ExteriorRing(hull) END;

	dist = 0;
	-- Brute Force - check every pair
	FOR i in 1 .. (ST_NumPoints(ring)-2)
		LOOP
			FOR j in i .. (ST_NumPoints(ring)-1)
				LOOP
				d = ST_Distance(ST_PointN(ring,i),ST_PointN(ring,j));
				-- Check the distance and update if larger
				IF (d &gt; dist) THEN
					dist = d;
					idx1 = i;
					idx2 = j;
				END IF;
			END LOOP;
		END LOOP;

	-- We now have the diameter of the convex hull.  The following line returns it if desired.
	-- RETURN MakeLine(PointN(ring,idx1),PointN(ring,idx2));

	-- Now for the Minimum Bounding Circle.  Since we know the two points furthest from each
	-- other, the MBC must go through those two points. Start with those points as a diameter of a circle.

	-- The radius is half the distance between them and the center is midway between them
	radius = ST_Distance(ST_PointN(ring,idx1),ST_PointN(ring,idx2)) / 2.0;
	center = ST_Line_interpolate_point(ST_MakeLine(ST_PointN(ring,idx1),ST_PointN(ring,idx2)),0.5);

	-- Loop through each vertex and check if the distance from the center to the point
	-- is greater than the current radius.
	FOR k in 1 .. (ST_NumPoints(ring)-1)
		LOOP
		IF(k &lt;&gt; idx1 and k &lt;&gt; idx2) THEN
			dist = ST_Distance(center,ST_PointN(ring,k));
			IF (dist &gt; radius) THEN
				-- We have to expand the circle.  The new circle must pass trhough
				-- three points - the two original diameters and this point.

				-- Draw a line from the first diameter to this point
				l1 = ST_Makeline(ST_PointN(ring,idx1),ST_PointN(ring,k));
				-- Compute the midpoint
				p1 = ST_line_interpolate_point(l1,0.5);
				-- Rotate the line 90 degrees around the midpoint (perpendicular bisector)
				l1 = ST_Translate(ST_Rotate(ST_Translate(l1,-X(p1),-Y(p1)),pi()/2),X(p1),Y(p1));
				--  Compute the azimuth of the bisector
				a1 = ST_Azimuth(ST_PointN(l1,1),ST_PointN(l1,2));
				--  Extend the line in each direction the new computed distance to insure they will intersect
				l1 = ST_AddPoint(l1,ST_Makepoint(X(ST_PointN(l1,2))+sin(a1)*dist,Y(ST_PointN(l1,2))+cos(a1)*dist),-1);
				l1 = ST_AddPoint(l1,ST_Makepoint(X(ST_PointN(l1,1))-sin(a1)*dist,Y(ST_PointN(l1,1))-cos(a1)*dist),0);

				-- Repeat for the line from the point to the other diameter point
				l2 = ST_Makeline(ST_PointN(ring,idx2),ST_PointN(ring,k));
				p2 = ST_Line_interpolate_point(l2,0.5);
				l2 = ST_Translate(ST_Rotate(ST_Translate(l2,-X(p2),-Y(p2)),pi()/2),X(p2),Y(p2));
				a2 = ST_Azimuth(ST_PointN(l2,1),ST_PointN(l2,2));
				l2 = ST_AddPoint(l2,ST_Makepoint(X(ST_PointN(l2,2))+sin(a2)*dist,Y(ST_PointN(l2,2))+cos(a2)*dist),-1);
				l2 = ST_AddPoint(l2,ST_Makepoint(X(ST_PointN(l2,1))-sin(a2)*dist,Y(ST_PointN(l2,1))-cos(a2)*dist),0);

				-- The new center is the intersection of the two bisectors
				center = ST_Intersection(l1,l2);
				-- The new radius is the distance to any of the three points
				radius = ST_Distance(center,ST_PointN(ring,idx1));
			END IF;
		END IF;
		END LOOP;
	--DONE!!  Return the MBC via the buffer command
	RETURN ST_Buffer(center,radius,segs_per_quarter);

	END;
$$
  LANGUAGE plpgsql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mlinefromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_mlinefromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'MULTILINESTRING'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mlinefromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_mlinefromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE
	WHEN geometrytype(GeomFromText($1, $2)) = 'MULTILINESTRING'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mlinefromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_mlinefromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mlinefromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION st_mlinefromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTILINESTRING'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mpointfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_mpointfromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'MULTIPOINT'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mpointfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_mpointfromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'MULTIPOINT'
	THEN GeomFromText($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mpointfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_mpointfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mpointfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION st_mpointfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTIPOINT'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mpolyfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_mpolyfromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'MULTIPOLYGON'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mpolyfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_mpolyfromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'MULTIPOLYGON'
	THEN ST_GeomFromText($1,$2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mpolyfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_mpolyfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_mpolyfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION st_mpolyfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_multi(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_multi(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_force_multi'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_multilinefromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_multilinefromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_multilinestringfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_multilinestringfromtext(text) 
  RETURNS geometry AS 
$$SELECT ST_MLineFromText($1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_multilinestringfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_multilinestringfromtext(text, integer) 
  RETURNS geometry AS 
$$SELECT MLineFromText($1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_multipointfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_multipointfromtext(text) 
  RETURNS geometry AS 
$$SELECT MPointFromText($1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_multipointfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_multipointfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_multipointfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION st_multipointfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1,$2)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_multipolyfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_multipolyfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_multipolyfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION st_multipolyfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_multipolygonfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_multipolygonfromtext(text) 
  RETURNS geometry AS 
$$SELECT MPolyFromText($1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_multipolygonfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_multipolygonfromtext(text, integer) 
  RETURNS geometry AS 
$$SELECT MPolyFromText($1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_ndims(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_ndims(geometry) 
  RETURNS smallint AS 
$$'$libdir/postgis-1.5', 'LWGEOM_ndims'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_npoints(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_npoints(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_npoints'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_nrings(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_nrings(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_nrings'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_numgeometries(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_numgeometries(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_numgeometries_collection'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_numinteriorring(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_numinteriorring(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_numinteriorrings_polygon'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_numinteriorrings(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_numinteriorrings(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_numinteriorrings_polygon'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_numpoints(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_numpoints(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_numpoints_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_orderingequals(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_orderingequals(geometry, geometry) 
  RETURNS boolean AS 
$$ 
	SELECT $1 ~= $2 AND _ST_OrderingEquals($1, $2)
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_overlaps(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_overlaps(geometry, geometry) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_Overlaps($1,$2)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_perimeter(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_perimeter(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_perimeter2d_poly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_perimeter2d(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_perimeter2d(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_perimeter2d_poly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_perimeter3d(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_perimeter3d(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_perimeter_poly'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_point(double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_point(double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_makepoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_point_inside_circle(geometry, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_point_inside_circle(geometry, double precision, double precision, double precision) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'LWGEOM_inside_circle_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_pointfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_pointfromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'POINT'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_pointfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_pointfromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'POINT'
	THEN ST_GeomFromText($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_pointfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_pointfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'POINT'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_pointfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION st_pointfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'POINT'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_pointn(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_pointn(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_pointn_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_pointonsurface(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_pointonsurface(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'pointonsurface'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_polyfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_polyfromtext(text) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'POLYGON'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_polyfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_polyfromtext(text, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'POLYGON'
	THEN ST_GeomFromText($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_polyfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_polyfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'POLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_polyfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION st_polyfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'POLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_polygon(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_polygon(geometry, integer) 
  RETURNS geometry AS 
$$ 
	SELECT setSRID(makepolygon($1), $2)
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_polygonfromtext(text)">
      <src>CREATE OR REPLACE FUNCTION st_polygonfromtext(text) 
  RETURNS geometry AS 
$$SELECT ST_PolyFromText($1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_polygonfromtext(text, integer)">
      <src>CREATE OR REPLACE FUNCTION st_polygonfromtext(text, integer) 
  RETURNS geometry AS 
$$SELECT PolyFromText($1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_polygonfromwkb(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_polygonfromwkb(bytea) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'POLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_polygonfromwkb(bytea, integer)">
      <src>CREATE OR REPLACE FUNCTION st_polygonfromwkb(bytea, integer) 
  RETURNS geometry AS 
$$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1,$2)) = 'POLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_polygonize(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_polygonize(geometry) 
  RETURNS geometry AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_polygonize(geometry[])">
      <src>CREATE OR REPLACE FUNCTION st_polygonize(geometry[]) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'polygonize_garray'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_polygonize_garray(geometry[])">
      <src>CREATE OR REPLACE FUNCTION st_polygonize_garray(geometry[]) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'polygonize_garray'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_postgis_gist_joinsel(internal, oid, internal, smallint)">
      <src>CREATE OR REPLACE FUNCTION st_postgis_gist_joinsel(internal, oid, internal, smallint) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_joinsel'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_postgis_gist_sel(internal, oid, internal, integer)">
      <src>CREATE OR REPLACE FUNCTION st_postgis_gist_sel(internal, oid, internal, integer) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_gist_sel'$$
  LANGUAGE c VOLATILE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_relate(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_relate(geometry, geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'relate_full'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_relate(geometry, geometry, text)">
      <src>CREATE OR REPLACE FUNCTION st_relate(geometry, geometry, text) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'relate_pattern'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_removepoint(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_removepoint(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_removepoint'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_reverse(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_reverse(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_reverse'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_rotate(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_rotate(geometry, double precision) 
  RETURNS geometry AS 
$$SELECT rotateZ($1, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_rotatex(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_rotatex(geometry, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1, 1, 0, 0, 0, cos($2), -sin($2), 0, sin($2), cos($2), 0, 0, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_rotatey(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_rotatey(geometry, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1,  cos($2), 0, sin($2),  0, 1, 0,  -sin($2), 0, cos($2), 0,  0, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_rotatez(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_rotatez(geometry, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1,  cos($2), -sin($2), 0,  sin($2), cos($2), 0,  0, 0, 1,  0, 0, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_scale(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_scale(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT scale($1, $2, $3, 1)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_scale(geometry, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_scale(geometry, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1,  $2, 0, 0,  0, $3, 0,  0, 0, $4,  0, 0, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_segmentize(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_segmentize(geometry, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_segmentize2d'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_setfactor(chip, real)">
      <src>CREATE OR REPLACE FUNCTION st_setfactor(chip, real) 
  RETURNS chip AS 
$$'$libdir/postgis-1.5', 'CHIP_setFactor'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_setpoint(geometry, integer, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_setpoint(geometry, integer, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_setpoint_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_setsrid(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_setsrid(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_setSRID'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_shift_longitude(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_shift_longitude(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_longitude_shift'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_shortestline(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_shortestline(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_shortestline2d'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_simplify(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_simplify(geometry, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_simplify2d'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_simplifypreservetopology(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_simplifypreservetopology(geometry, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'topologypreservesimplify'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_snaptogrid(geometry, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_snaptogrid(geometry, double precision) 
  RETURNS geometry AS 
$$SELECT ST_SnapToGrid($1, 0, 0, $2, $2)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_snaptogrid(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_snaptogrid(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT ST_SnapToGrid($1, 0, 0, $2, $3)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_snaptogrid(geometry, double precision, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_snaptogrid(geometry, double precision, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_snaptogrid'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_snaptogrid_pointoff'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_spheroid_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION st_spheroid_in(cstring) 
  RETURNS spheroid AS 
$$'$libdir/postgis-1.5', 'ellipsoid_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_spheroid_out(spheroid)">
      <src>CREATE OR REPLACE FUNCTION st_spheroid_out(spheroid) 
  RETURNS cstring AS 
$$'$libdir/postgis-1.5', 'ellipsoid_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_srid(chip)">
      <src>CREATE OR REPLACE FUNCTION st_srid(chip) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'CHIP_getSRID'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_srid(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_srid(geometry) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'LWGEOM_getSRID'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_startpoint(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_startpoint(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_startpoint_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_summary(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_summary(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_summary'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_symdifference(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_symdifference(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'symdifference'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_symmetricdifference(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_symmetricdifference(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'symdifference'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_text(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_text(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_to_text'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_touches(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_touches(geometry, geometry) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_Touches($1,$2)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_transform(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION st_transform(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'transform'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_translate(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_translate(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT translate($1, $2, $3, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_translate(geometry, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_translate(geometry, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1, 1, 0, 0, 0, 1, 0, 0, 0, 1, $2, $3, $4)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_transscale(geometry, double precision, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION st_transscale(geometry, double precision, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1,  $4, 0, 0,  0, $5, 0,
		0, 0, 1,  $2 * $4, $3 * $5, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="st_union(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_union(geometry) 
  RETURNS geometry AS 
$$aggregate_dummy$$
  LANGUAGE internal IMMUTABLE 
  COST 1;</src>
    </Proc>
    <Proc nm="st_union(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_union(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'geomunion'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_union(geometry[])">
      <src>CREATE OR REPLACE FUNCTION st_union(geometry[]) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'pgis_union_geometry_array'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_unite_garray(geometry[])">
      <src>CREATE OR REPLACE FUNCTION st_unite_garray(geometry[]) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'pgis_union_geometry_array'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_width(chip)">
      <src>CREATE OR REPLACE FUNCTION st_width(chip) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'CHIP_getWidth'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_within(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION st_within(geometry, geometry) 
  RETURNS boolean AS 
$$SELECT $1 &amp;&amp; $2 AND _ST_Within($1,$2)$$
  LANGUAGE sql IMMUTABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="st_wkbtosql(bytea)">
      <src>CREATE OR REPLACE FUNCTION st_wkbtosql(bytea) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_from_WKB'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_wkttosql(text)">
      <src>CREATE OR REPLACE FUNCTION st_wkttosql(text) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_from_text'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_x(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_x(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_x_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_xmax(box3d)">
      <src>CREATE OR REPLACE FUNCTION st_xmax(box3d) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'BOX3D_xmax'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_xmin(box3d)">
      <src>CREATE OR REPLACE FUNCTION st_xmin(box3d) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'BOX3D_xmin'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_y(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_y(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_y_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_ymax(box3d)">
      <src>CREATE OR REPLACE FUNCTION st_ymax(box3d) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'BOX3D_ymax'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_ymin(box3d)">
      <src>CREATE OR REPLACE FUNCTION st_ymin(box3d) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'BOX3D_ymin'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_z(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_z(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_z_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_zmax(box3d)">
      <src>CREATE OR REPLACE FUNCTION st_zmax(box3d) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'BOX3D_zmax'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_zmflag(geometry)">
      <src>CREATE OR REPLACE FUNCTION st_zmflag(geometry) 
  RETURNS smallint AS 
$$'$libdir/postgis-1.5', 'LWGEOM_zmflag'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="st_zmin(box3d)">
      <src>CREATE OR REPLACE FUNCTION st_zmin(box3d) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'BOX3D_zmin'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="startpoint(geometry)">
      <src>CREATE OR REPLACE FUNCTION startpoint(geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'LWGEOM_startpoint_linestring'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="summary(geometry)">
      <src>CREATE OR REPLACE FUNCTION summary(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_summary'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="symdifference(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION symdifference(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'symdifference'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="symmetricdifference(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION symmetricdifference(geometry, geometry) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'symdifference'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="text(geometry)">
      <src>CREATE OR REPLACE FUNCTION text(geometry) 
  RETURNS text AS 
$$'$libdir/postgis-1.5', 'LWGEOM_to_text'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="touches(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION touches(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'touches'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="transform(geometry, integer)">
      <src>CREATE OR REPLACE FUNCTION transform(geometry, integer) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'transform'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="translate(geometry, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION translate(geometry, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT translate($1, $2, $3, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="translate(geometry, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION translate(geometry, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1, 1, 0, 0, 0, 1, 0, 0, 0, 1, $2, $3, $4)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="transscale(geometry, double precision, double precision, double precision, double precision)">
      <src>CREATE OR REPLACE FUNCTION transscale(geometry, double precision, double precision, double precision, double precision) 
  RETURNS geometry AS 
$$SELECT affine($1,  $4, 0, 0,  0, $5, 0,
		0, 0, 1,  $2 * $4, $3 * $5, 0)$$
  LANGUAGE sql IMMUTABLE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="unite_garray(geometry[])">
      <src>CREATE OR REPLACE FUNCTION unite_garray(geometry[]) 
  RETURNS geometry AS 
$$'$libdir/postgis-1.5', 'pgis_union_geometry_array'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="unlockrows(text)">
      <src>CREATE OR REPLACE FUNCTION unlockrows(text) 
  RETURNS integer AS 
$$ 
DECLARE
	ret int;
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table where authid = ' ||
		quote_literal($1);

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;
$$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="updategeometrysrid(character varying, character varying, character varying, character varying, integer)">
      <src>CREATE OR REPLACE FUNCTION updategeometrysrid(character varying, character varying, character varying, character varying, integer) 
  RETURNS text AS 
$$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	column_name alias for $4;
	new_srid alias for $5;
	myrec RECORD;
	okay boolean;
	cname varchar;
	real_schema name;

BEGIN


	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = 'f';

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := 't';
		END LOOP;

		IF ( okay &lt;&gt; 't' ) THEN
			RAISE EXCEPTION 'Invalid schema name';
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT INTO real_schema current_schema()::text;
	END IF;

	-- Find out if the column is in the geometry_columns table
	okay = 'f';
	FOR myrec IN SELECT * from geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := 't';
	END LOOP;
	IF (okay &lt;&gt; 't') THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN 'f';
	END IF;

	-- Update ref from geometry_columns table
	EXECUTE 'UPDATE geometry_columns SET SRID = ' || new_srid::text ||
		' where f_table_schema = ' ||
		quote_literal(real_schema) || ' and f_table_name = ' ||
		quote_literal(table_name)  || ' and f_geometry_column = ' ||
		quote_literal(column_name);

	-- Make up constraint name
	cname = 'enforce_srid_'  || column_name;

	-- Drop enforce_srid constraint
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
		'.' || quote_ident(table_name) ||
		' DROP constraint ' || quote_ident(cname);

	-- Update geometries SRID
	EXECUTE 'UPDATE ' || quote_ident(real_schema) ||
		'.' || quote_ident(table_name) ||
		' SET ' || quote_ident(column_name) ||
		' = setSRID(' || quote_ident(column_name) ||
		', ' || new_srid::text || ')';

	-- Reset enforce_srid constraint
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
		'.' || quote_ident(table_name) ||
		' ADD constraint ' || quote_ident(cname) ||
		' CHECK (srid(' || quote_ident(column_name) ||
		') = ' || new_srid::text || ')';

	RETURN real_schema || '.' || table_name || '.' || column_name ||' SRID changed to ' || new_srid::text;

END;
$$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="updategeometrysrid(character varying, character varying, character varying, integer)">
      <src>CREATE OR REPLACE FUNCTION updategeometrysrid(character varying, character varying, character varying, integer) 
  RETURNS text AS 
$$
DECLARE
	ret  text;
BEGIN
	SELECT UpdateGeometrySRID('',$1,$2,$3,$4) into ret;
	RETURN ret;
END;
$$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="updategeometrysrid(character varying, character varying, integer)">
      <src>CREATE OR REPLACE FUNCTION updategeometrysrid(character varying, character varying, integer) 
  RETURNS text AS 
$$
DECLARE
	ret  text;
BEGIN
	SELECT UpdateGeometrySRID('','',$1,$2,$3) into ret;
	RETURN ret;
END;
$$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;</src>
    </Proc>
    <Proc nm="width(chip)">
      <src>CREATE OR REPLACE FUNCTION width(chip) 
  RETURNS integer AS 
$$'$libdir/postgis-1.5', 'CHIP_getWidth'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="within(geometry, geometry)">
      <src>CREATE OR REPLACE FUNCTION within(geometry, geometry) 
  RETURNS boolean AS 
$$'$libdir/postgis-1.5', 'within'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="x(geometry)">
      <src>CREATE OR REPLACE FUNCTION x(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_x_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="xmax(box3d)">
      <src>CREATE OR REPLACE FUNCTION xmax(box3d) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'BOX3D_xmax'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="xmin(box3d)">
      <src>CREATE OR REPLACE FUNCTION xmin(box3d) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'BOX3D_xmin'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="y(geometry)">
      <src>CREATE OR REPLACE FUNCTION y(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_y_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="ymax(box3d)">
      <src>CREATE OR REPLACE FUNCTION ymax(box3d) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'BOX3D_ymax'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="ymin(box3d)">
      <src>CREATE OR REPLACE FUNCTION ymin(box3d) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'BOX3D_ymin'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="z(geometry)">
      <src>CREATE OR REPLACE FUNCTION z(geometry) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'LWGEOM_z_point'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="zmax(box3d)">
      <src>CREATE OR REPLACE FUNCTION zmax(box3d) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'BOX3D_zmax'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="zmflag(geometry)">
      <src>CREATE OR REPLACE FUNCTION zmflag(geometry) 
  RETURNS smallint AS 
$$'$libdir/postgis-1.5', 'LWGEOM_zmflag'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="zmin(box3d)">
      <src>CREATE OR REPLACE FUNCTION zmin(box3d) 
  RETURNS double precision AS 
$$'$libdir/postgis-1.5', 'BOX3D_zmin'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <View nm="geography_columns">
      <Sql>SELECT
    current_database() AS f_table_catalog,
    n.nspname AS f_table_schema,
    c.relname AS f_table_name,
    a.attname AS f_geography_column,
    geography_typmod_dims(a.atttypmod) AS coord_dimension,
    geography_typmod_srid(a.atttypmod) AS srid,
    geography_typmod_type(a.atttypmod) AS type
FROM pg_class c,
    pg_attribute a,
    pg_type t,
    pg_namespace n
WHERE t.typname = 'geography'::name
        AND a.attisdropped = false
        AND a.atttypid = t.oid
        AND a.attrelid = c.oid
        AND c.relnamespace = n.oid
        AND NOT pg_is_other_temp_schema(c.relnamespace)</Sql>
    </View>
    <Seq incr="1" nm="capabilities_id_seq"/>
    <Seq incr="1" nm="capabilities_roles_id_seq"/>
    <Seq incr="1" nm="itineraries_id_seq"/>
    <Seq incr="1" nm="itineraries_paths_id_seq"/>
    <Seq incr="1" nm="itineraries_pois_id_seq"/>
    <Seq incr="1" nm="paths_gid_seq"/>
    <Seq incr="1" nm="pois_gid_seq"/>
    <Seq incr="1" nm="roles_id_seq"/>
    <Seq incr="1" nm="roles_users_id_seq"/>
    <Seq incr="1" nm="routes_gid_seq"/>
    <Seq incr="1" nm="typolgies_id_seq"/>
    <Seq incr="1" nm="typologies_paths_id_seq"/>
    <Seq incr="1" nm="typologies_pois_id_seq"/>
    <Seq incr="1" nm="user_datas_id_seq"/>
    <Seq incr="1" nm="users_id_seq"/>
    <CustomTypes>
      <CustomType id="5001" nm="geometry"/>
    </CustomTypes>
  </Sch>
  <Dgm nm="diagramA">
    <RnCf FtSz="9" lkStgy="OffsetDirect" zm="1.0">
      <VbCfg>
        <Fg ky="Auto Number" vl="0"/>
        <Fg ky="Check" vl="0"/>
        <Fg ky="Comment" vl="0"/>
        <Fg ky="Data Type" vl="1"/>
        <Fg ky="Default" vl="0"/>
        <Fg ky="ENUM Values" vl="0"/>
        <Fg ky="Length" vl="1"/>
        <Fg ky="Name" vl="1"/>
        <Fg ky="Nullable" vl="0"/>
        <Fg ky="Schema Name" vl="0"/>
        <Fg ky="Signed" vl="0"/>
      </VbCfg>
    </RnCf>
    <DiaProps>
      <Show AllCols="1" FkCols="1" PkCols="1"/>
    </DiaProps>
    <TbGl bkCl="ffccccff" sch="public" tbl="capabilities" x="354" y="147"/>
    <TbGl bkCl="ffccccff" sch="public" tbl="capabilities_roles" x="98" y="145"/>
    <TbGl bkCl="ffccccff" sch="public" tbl="geometry_columns" x="1603" y="144"/>
    <TbGl bkCl="ffccccff" sch="public" tbl="roles" x="360" y="215"/>
    <TbGl bkCl="ffccccff" sch="public" tbl="roles_users" x="371" y="308"/>
    <TbGl bkCl="ffccccff" sch="public" tbl="spatial_ref_sys" x="1646" y="50"/>
    <TbGl bkCl="ffccccff" sch="public" tbl="user_datas" x="93" y="399"/>
    <TbGl bkCl="ffccccff" sch="public" tbl="users" x="92" y="230"/>
    <TbGl bkCl="ffff6666" sch="public" tbl="itineraries" x="670" y="119"/>
    <TbGl bkCl="ffff6666" sch="public" tbl="pois" x="1044" y="114"/>
    <TbGl bkCl="ffff6666" sch="public" tbl="paths" x="1042" y="255"/>
    <TbGl bkCl="ffff6666" sch="public" tbl="itineraries_pois" x="867" y="121"/>
    <TbGl bkCl="ffff6666" sch="public" tbl="itineraries_paths" x="853" y="249"/>
    <TbGl bkCl="ffcccccc" sch="public" tbl="typologies" x="1463" y="265"/>
    <TbGl bkCl="ffcccccc" sch="public" tbl="typologies_paths" x="1289" y="297"/>
    <TbGl bkCl="ffcccccc" sch="public" tbl="typologies_pois" x="1298" y="132"/>
    <TbGl bkCl="ff3399ff" sch="public" tbl="i18n" x="699" y="333"/>
    <FkGl bkCl="ff000000" nm="public.capabilities_roles.fk_capabilities_roles_capabilities"/>
    <FkGl bkCl="ff000000" nm="public.capabilities_roles.fk_capabilities_roles_roles"/>
    <FkGl bkCl="ff000000" nm="public.itineraries_paths.fk_itineraries_paths_itineraries"/>
    <FkGl bkCl="ff000000" nm="public.itineraries_paths.fk_itineraries_paths_paths"/>
    <FkGl bkCl="ff000000" nm="public.itineraries_pois.fk_itineraries_pois_itineraries"/>
    <FkGl bkCl="ff000000" nm="public.itineraries_pois.fk_itineraries_pois_pois"/>
    <FkGl bkCl="ff000000" nm="public.roles_users.fk_roles_users_roles"/>
    <FkGl bkCl="ff000000" nm="public.roles_users.fk_roles_users_users"/>
    <FkGl bkCl="ff000000" nm="public.typologies_paths.fk_typologies_paths_paths"/>
    <FkGl bkCl="ff000000" nm="public.typologies_paths.fk_typologies_paths_typolgies"/>
    <FkGl bkCl="ff000000" nm="public.typologies_pois.fk_typologies_pois_pois"/>
    <FkGl bkCl="ff000000" nm="public.typologies_pois.fk_typologies_pois_typologies"/>
    <FkGl bkCl="ff000000" nm="public.user_datas.fk_user_datas_users"/>
    <Notes/>
    <Zones/>
  </Dgm>
  <RnmMgr NxRnmId="10">
    <RnmCh ObjCls="Table" ParCls="Schema" ParNme="public" SupCls="" SupNme="">
      <Rnm id="2" nNm="itineraries" oNm="itinerari"/>
      <Rnm id="1" nNm="itinerari" oNm="itineraries"/>
    </RnmCh>
    <RnmCh ObjCls="Column" ParCls="Table" ParNme="pois" SupCls="Schema" SupNme="public">
      <Rnm id="3" nNm="accessibility" oNm="acessibility"/>
    </RnmCh>
    <RnmCh ObjCls="Column" ParCls="Table" ParNme="pois" SupCls="Schema" SupNme="public">
      <Rnm id="4" nNm="id" oNm="gid"/>
    </RnmCh>
    <RnmCh ObjCls="Column" ParCls="Table" ParNme="itineraries_pois" SupCls="Schema" SupNme="public">
      <Rnm id="5" nNm="poi_id" oNm="poi_gid"/>
    </RnmCh>
    <RnmCh ObjCls="Column" ParCls="Table" ParNme="paths" SupCls="Schema" SupNme="public">
      <Rnm id="6" nNm="id" oNm="gid"/>
    </RnmCh>
    <RnmCh ObjCls="Table" ParCls="Schema" ParNme="public" SupCls="" SupNme="">
      <Rnm id="7" nNm="typologies" oNm="typolgies"/>
    </RnmCh>
    <RnmCh ObjCls="Column" ParCls="Table" ParNme="i18n" SupCls="Schema" SupNme="public">
      <Rnm id="9" nNm="tb" oNm="tabl"/>
      <Rnm id="8" nNm="tabl" oNm="table"/>
    </RnmCh>
  </RnmMgr>
  <DbDocOptionMgr>
    <BasicOptionMgr>
      <Name>db.doc.option.mgr</Name>
      <BoolOpt lbl="Diagrams" nm="doc.diagrams" on="1" spl="0"/>
      <BoolOpt lbl="Foreign Keys" nm="doc.fks" on="1" spl="0"/>
      <BoolOpt lbl="Indexes" nm="doc.indexes" on="1" spl="0"/>
      <BoolOpt lbl="Overwrite CSS File" nm="doc.overwrite.css" on="1" spl="0"/>
      <BoolOpt lbl="Procedures" nm="doc.procs" on="1" spl="0"/>
      <BoolOpt lbl="Schemas" nm="doc.schemas" on="1" spl="0"/>
      <BoolOpt lbl="Sequences" nm="doc.sequences" on="1" spl="0"/>
      <BoolOpt lbl="Tables" nm="doc.tables" on="1" spl="0"/>
      <BoolOpt lbl="Triggers" nm="doc.triggers" on="1" spl="0"/>
      <BoolOpt lbl="Views" nm="doc.views" on="1" spl="0"/>
    </BasicOptionMgr>
  </DbDocOptionMgr>
  <OpenEditors>
    <OpenEditor ClsNm="Diagram" fqn="null.diagramA" selected="1"/>
  </OpenEditors>
  <TreePaths>
    <TreePath/>
    <TreePath>/Schemas (1)</TreePath>
    <TreePath>/Schemas (1)/public</TreePath>
    <TreePath>/Schemas (1)/public/Tables (17)</TreePath>
  </TreePaths>
</Db>
